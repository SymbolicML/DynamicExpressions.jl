<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Node and Tree Operations · DynamicExpressions.jl</title><meta name="title" content="Node and Tree Operations · DynamicExpressions.jl"/><meta property="og:title" content="Node and Tree Operations · DynamicExpressions.jl"/><meta property="twitter:title" content="Node and Tree Operations · DynamicExpressions.jl"/><meta name="description" content="Documentation for DynamicExpressions.jl."/><meta property="og:description" content="Documentation for DynamicExpressions.jl."/><meta property="twitter:description" content="Documentation for DynamicExpressions.jl."/><meta property="og:url" content="https://ai.damtp.cam.ac.uk/dynamicexpressions/stable/examples/base_operations/"/><meta property="twitter:url" content="https://ai.damtp.cam.ac.uk/dynamicexpressions/stable/examples/base_operations/"/><link rel="canonical" href="https://ai.damtp.cam.ac.uk/dynamicexpressions/stable/examples/base_operations/"/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="DynamicExpressions.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">DynamicExpressions.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Examples</span><ul><li class="is-active"><a class="tocitem" href>Node and Tree Operations</a></li><li><a class="tocitem" href="../expression/"><code>Expression</code> example</a></li><li><a class="tocitem" href="../structured_expression/"><code>StructuredExpression</code> example</a></li></ul></li><li><a class="tocitem" href="../../eval/">Eval</a></li><li><a class="tocitem" href="../../utils/">Utils</a></li><li><a class="tocitem" href="../../api/">API</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Examples</a></li><li class="is-active"><a href>Node and Tree Operations</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Node and Tree Operations</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/SymbolicML/DynamicExpressions.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/SymbolicML/DynamicExpressions.jl/blob/master/test/test_base_2.jl" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Node-and-Tree-Operations"><a class="docs-heading-anchor" href="#Node-and-Tree-Operations">Node and Tree Operations</a><a id="Node-and-Tree-Operations-1"></a><a class="docs-heading-anchor-permalink" href="#Node-and-Tree-Operations" title="Permalink"></a></h1><p>This example demonstrates how to create and manipulate expression trees using the <a href="../../api/#DynamicExpressions.NodeModule.Node"><code>Node</code></a> type.</p><p>First, let&#39;s create a node to reference <code>feature=1</code> of our dataset:</p><pre><code class="language-julia hljs">using DynamicExpressions, Random

x = Node{Float64}(; feature=1)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">x1</code></pre><p>We can also create values, using <code>val</code>:</p><pre><code class="language-julia hljs">const_1 = Node{Float64}(; val=1.0)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">1.0</code></pre><p>Now, let&#39;s declare some operators to use in our expression tree.</p><p>Note that the declaration of the <code>OperatorEnum</code> updates a global mapping from operators to their index in a list. This is purely for convenience, and most of the time, you would either operate directly on the <code>OperatorEnum</code>, like with <a href="../../eval/#DynamicExpressions.EvaluateModule.eval_tree_array-Union{Tuple{T}, Tuple{AbstractExpressionNode{T}, AbstractMatrix{T}, OperatorEnum}} where T"><code>eval_tree_array</code></a>, or use <a href="../../api/#DynamicExpressions.ExpressionModule.Expression"><code>Expression</code></a> objects to store them alongside the expression.</p><pre><code class="language-julia hljs">operators = OperatorEnum(; unary_operators=(sin, exp), binary_operators=(+, -, *, /))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">OperatorEnum{Tuple{typeof(+), typeof(-), typeof(*), typeof(/)}, Tuple{typeof(sin), typeof(exp)}}((+, -, *, /), (sin, exp))</code></pre><p>Now, let&#39;s create another variable</p><pre><code class="language-julia hljs">y = Node{Float64}(; feature=2)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">x2</code></pre><p>And we can now create expression trees:</p><pre><code class="language-julia hljs">tree = (x + y) * const_1 - sin(x)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">((x1 + x2) * 1.0) - sin(x1)</code></pre><p>The type of this is the same as the type of the variables and constants, meaning we have type stability:</p><pre><code class="language-julia hljs">typeof(tree), typeof(x)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">(Node{Float64}, Node{Float64})</code></pre><p>We can also just use scalars directly:</p><pre><code class="language-julia hljs">tree2 = 2x - sin(x)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">(2.0 * x1) - sin(x1)</code></pre><p>As you have noticed, the tree is printed as an expression. We can control this with the <a href="../../utils/#DynamicExpressions.StringsModule.string_tree-Tuple{Node, AbstractOperatorEnum}"><code>string_tree</code></a> function, which also lets us pass the <code>operators</code> explicitly:</p><pre><code class="language-julia hljs">string_tree(tree, operators; variable_names=[&quot;x&quot;, &quot;y&quot;])</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">&quot;((x + y) * 1.0) - sin(x)&quot;</code></pre><p>This also lets us control how each branch node and leaf node (variable/constant) is printed in the tree.</p><p>There are a lot of operations you can do on tree objects, such as evaluating them over batched data:</p><pre><code class="language-julia hljs">rng = Random.MersenneTwister(0)
tree2(randn(rng, Float64, 2, 5), operators)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">5-element Vector{Float64}:
 -0.8294606488323947
  0.048708950844390406
 -0.68944309464339
 -1.4260885069685918
  0.9044418888295086</code></pre><p>Now, how does this actually work? How do these functions traverse the tree?</p><p>The core operation is the <a href="../../utils/#DynamicExpressions.NodeModule.tree_mapreduce"><code>tree_mapreduce</code></a> function, which applies a function to each node in the tree, and then combines the results. Unlike a standard <code>mapreduce</code>, the <code>tree_mapreduce</code> allows you to specify different maps for branch nodes and leaf nodes. Also unlike a <code>mapreduce</code>, the reduction function needs to handle a variable number of inputs – it takes the mapped branch node, as well as all of the mapped children.</p><p>Let&#39;s see an example. Say we just want to count the nodes in the tree:</p><pre><code class="language-julia hljs">num_nodes = tree_mapreduce(node -&gt; 1, +, tree)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">8</code></pre><p>Here, the <code>+</code> handles both the cases of 1 child and 2 children. Here, we didn&#39;t need to specify a custom branch function, but we could do that too:</p><pre><code class="language-julia hljs">num_leafs = tree_mapreduce(leaf_node -&gt; 1, branch_node -&gt; 0, +, tree)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">4</code></pre><p>This counts the number of leaf nodes in the tree. For <code>tree</code>, this was <code>x</code>, <code>y</code>, <code>const_1</code>, and <code>x</code>.</p><p>You can access fields of the <a href="../../api/#DynamicExpressions.NodeModule.Node"><code>Node</code></a> type here to create more complex operations, just be careful to not access undefined fields (be sure to read the API specification).</p><p>Most operators can be built with this simple pattern, even including evaluation of the tree, and printing of expressions. (It also allows for graph-like expressions like <a href="../../api/#DynamicExpressions.NodeModule.GraphNode"><code>GraphNode</code></a> via a <code>f_on_shared</code> keyword.)</p><p>As a more complex example, let&#39;s compute the depth of a tree. Here, we need to use a more complicated reduction operation – the <code>max</code>:</p><pre><code class="language-julia hljs">depth = tree_mapreduce(
    node -&gt; 1, (parent, children...) -&gt; 1 + max(children...), x + sin(sin(exp(x)))
)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">5</code></pre><p>Here, the <code>max</code> handles both the cases of 1 child and 2 children. The parent node contributes <code>1</code> at each depth. Note that the inputs to the reduction are already mapped to <code>1</code>.</p><p>Many operations do not need to handle branching, and thus, many of the typical operations on collections in Julia are available. For example, we can collect each node in the tree into a list:</p><pre><code class="language-julia hljs">collect(tree)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">8-element Vector{Node{Float64}}:
 ((x1 + x2) * 1.0) - sin(x1)
 (x1 + x2) * 1.0
 x1 + x2
 x1
 x2
 1.0
 sin(x1)
 x1</code></pre><p>Note that the first node in this list is the root note, which is the subtraction operation:</p><pre><code class="language-julia hljs">tree == first(collect(tree))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">true</code></pre><p>We can look at the operator:</p><pre><code class="language-julia hljs">tree.degree, tree.op</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">(0x02, 0x02)</code></pre><p>And compare it to our list:</p><pre><code class="language-julia hljs">operators.binops</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">(+, -, *, /)</code></pre><p>Many other collection operations are available. For example, we can aggregate a relationship over each node:</p><pre><code class="language-julia hljs">sum(node -&gt; node.degree == 0 ? 1.5 : 0.0, tree)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">6.0</code></pre><p>We can even use <code>any</code> which has an early exit from the depth-first tree traversal:</p><pre><code class="language-julia hljs">any(node -&gt; node.degree == 2, tree)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">true</code></pre><p>We can also randomly sample nodes, using <a href="../../utils/#DynamicExpressions.RandomModule.NodeSampler"><code>NodeSampler</code></a>, which permits filters:</p><pre><code class="language-julia hljs">rand(rng, NodeSampler(; tree, filter=node -&gt; node.degree == 1))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">sin(x1)</code></pre><hr/><p><em>This page was generated using <a href="https://github.com/fredrikekre/Literate.jl">Literate.jl</a>.</em></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../">« Home</a><a class="docs-footer-nextpage" href="../expression/"><code>Expression</code> example »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.8.1 on <span class="colophon-date" title="Friday 28 February 2025 20:00">Friday 28 February 2025</span>. Using Julia version 1.11.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
