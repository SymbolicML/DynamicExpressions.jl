<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Expression example · DynamicExpressions.jl</title><meta name="title" content="Expression example · DynamicExpressions.jl"/><meta property="og:title" content="Expression example · DynamicExpressions.jl"/><meta property="twitter:title" content="Expression example · DynamicExpressions.jl"/><meta name="description" content="Documentation for DynamicExpressions.jl."/><meta property="og:description" content="Documentation for DynamicExpressions.jl."/><meta property="twitter:description" content="Documentation for DynamicExpressions.jl."/><meta property="og:url" content="https://ai.damtp.cam.ac.uk/dynamicexpressions/stable/examples/expression/"/><meta property="twitter:url" content="https://ai.damtp.cam.ac.uk/dynamicexpressions/stable/examples/expression/"/><link rel="canonical" href="https://ai.damtp.cam.ac.uk/dynamicexpressions/stable/examples/expression/"/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="DynamicExpressions.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">DynamicExpressions.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../base_operations/">Node and Tree Operations</a></li><li class="is-active"><a class="tocitem" href><code>Expression</code> example</a></li><li><a class="tocitem" href="../structured_expression/"><code>StructuredExpression</code> example</a></li></ul></li><li><a class="tocitem" href="../../eval/">Eval</a></li><li><a class="tocitem" href="../../utils/">Utils</a></li><li><a class="tocitem" href="../../api/">API</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Examples</a></li><li class="is-active"><a href><code>Expression</code> example</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href><code>Expression</code> example</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/SymbolicML/DynamicExpressions.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/SymbolicML/DynamicExpressions.jl/blob/master/test/test_expressions.jl" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Expression-example"><a class="docs-heading-anchor" href="#Expression-example"><code>Expression</code> example</a><a id="Expression-example-1"></a><a class="docs-heading-anchor-permalink" href="#Expression-example" title="Permalink"></a></h1><p><code>Expression</code> is a fundamental type in DynamicExpressions that represents a mathematical expression as a tree structure. It combines an <code>AbstractExpressionNode</code> (typically a <code>Node</code>) with metadata like operators and variable names.</p><pre><code class="language-julia hljs">using DynamicExpressions, Random</code></pre><p>First, let&#39;s define our operators and variable names:</p><pre><code class="language-julia hljs">operators = OperatorEnum(;
    binary_operators=(+, -, *, /), unary_operators=(sin, cos, exp)
)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">OperatorEnum{Tuple{typeof(+), typeof(-), typeof(*), typeof(/)}, Tuple{typeof(sin), typeof(cos), typeof(exp)}}((+, -, *, /), (sin, cos, exp))</code></pre><pre><code class="language-julia hljs">variable_names = [&quot;x&quot;, &quot;y&quot;]</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">2-element Vector{String}:
 &quot;x&quot;
 &quot;y&quot;</code></pre><p>Now, let&#39;s create an Expression manually:</p><pre><code class="language-julia hljs">x = Node{Float64}(; feature=1)
x_expr = Expression(x; operators, variable_names)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">x</code></pre><p>We can build up more complex expressions using these basic building blocks:</p><pre><code class="language-julia hljs">y = Node{Float64}(; feature=2)
c = Node{Float64}(; val=2.0)
complex_node = Node(; op=3, l=x, r=Node(; op=1, l=y, r=c))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">x1 * (x2 + 2.0)</code></pre><p>where the <code>3</code> indicates <code>*</code> and <code>1</code> indicates <code>+</code>.</p><pre><code class="language-julia hljs">complex_expr = Expression(complex_node; operators, variable_names)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">x * (y + 2.0)</code></pre><p>This expression includes its own metadata: the operators and variable names, and so there are no scope issues as with raw <code>AbstractExpressionNode</code> types which depend on the last-used metadata for convenience functions like printing. In other words, you can print this expression, or evaluate it, directly:</p><pre><code class="language-julia hljs">rng = Random.MersenneTwister(0)
complex_expr(randn(rng, 2, 5))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">5-element Vector{Float64}:
 -1.542118170290465
  0.11814820390902947
 -1.3946630413928292
 -1.3397436535218281
  0.5217574649671659</code></pre><p>While creating expressions manually is faster, and should be preferred within packages, it can be cumbersome for quickly writing more complex expressions. DynamicExpressions provides a more convenient way to create expressions using the <code>parse_expression</code> function, which directly parses a Julia object:</p><pre><code class="language-julia hljs">parsed_expr = parse_expression(
    :(sin(2.0 * x + exp(y + 5.0))); operators=operators, variable_names=variable_names
)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">sin((2.0 * x) + exp(y + 5.0))</code></pre><p>We can convert an expression into the primitive <code>AbstractExpressionNode</code> type with <a href="../../api/#DynamicExpressions.ExpressionModule.get_tree"><code>get_tree</code></a>:</p><pre><code class="language-julia hljs">tree = get_tree(parsed_expr)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">sin((2.0 * x1) + exp(x2 + 5.0))</code></pre><p>Some <code>AbstractExpression</code> types may choose to store their expression in a different way than simply saving it as one of the fields. For any expression, you can get the raw contents with <a href="../../api/#DynamicExpressions.ExpressionModule.get_contents"><code>get_contents</code></a>:</p><pre><code class="language-julia hljs">get_contents(parsed_expr)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">sin((2.0 * x1) + exp(x2 + 5.0))</code></pre><p>Similarly, you can get the metadata for an expression with <a href="../../api/#DynamicExpressions.ExpressionModule.get_metadata"><code>get_metadata</code></a>:</p><pre><code class="language-julia hljs">get_metadata(parsed_expr)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Metadata((operators = OperatorEnum{Tuple{typeof(+), typeof(-), typeof(*), typeof(/)}, Tuple{typeof(sin), typeof(cos), typeof(exp)}}((+, -, *, /), (sin, cos, exp)), variable_names = [&quot;x&quot;, &quot;y&quot;]))</code></pre><p>These can be used with <a href="../../api/#DynamicExpressions.ExpressionModule.with_contents"><code>with_contents</code></a> and <a href="../../api/#DynamicExpressions.ExpressionModule.with_metadata"><code>with_metadata</code></a> to create new expressions based on the original:</p><pre><code class="language-julia hljs">with_contents(parsed_expr, Node(; op=2, l=get_contents(parsed_expr)))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">cos(sin((2.0 * x) + exp(y + 5.0)))</code></pre><p><code>Expression</code> objects support various operations defined on regular trees, which permits us to overload specific methods with modified behavior. For example, we can count the number of nodes, which simply forwards to the method as it is defined on <a href="../../api/#DynamicExpressions.NodeModule.Node"><code>Node</code></a>:</p><pre><code class="language-julia hljs">node_count = count_nodes(parsed_expr)
println(&quot;Number of nodes: $node_count&quot;)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Number of nodes: 9</code></pre><p>The [<code>tree_mapreduce</code>] will by default call <a href="../../api/#DynamicExpressions.ExpressionModule.get_tree"><code>get_tree</code></a> to get the tree, so it can be used with any expression type that overloads this method. For example, we can compute the depth of a tree:</p><pre><code class="language-julia hljs">tree_mapreduce(
    leaf -&gt; 1, branch -&gt; 1, (parent, child...) -&gt; parent + max(child...), parsed_expr
)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">5</code></pre><p>We can also perform more complex operations, like simplification:</p><pre><code class="language-julia hljs">complex_expr = parse_expression(
    :((2.0 + x) + 3.0); operators=operators, variable_names=[&quot;x&quot;]
)
simplified_expr = combine_operators(copy(complex_expr))
println(&quot;Original: &quot;, complex_expr)
println(&quot;Simplified: &quot;, simplified_expr)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Original: (2.0 + x) + 3.0
Simplified: x + 5.0</code></pre><p><code>AbstractExpression</code> types also have many operators in <code>Base</code> defined, which will automatically look up the matching index in the stored <a href="../../api/#DynamicExpressions.OperatorEnumModule.OperatorEnum"><code>OperatorEnum</code></a>. This means we can combine expressions like so:</p><pre><code class="language-julia hljs">xs = [Expression(Node{Float64}(; feature=i); operators, variable_names) for i in 1:5]

xs[1] + xs[2]</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">x + y</code></pre><p>These have the same type – they simply combine their <code>AbstractExpressionNode</code> objects and ensure the metadata is the same.</p><pre><code class="language-julia hljs">typeof(xs[1] + xs[2])</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Expression{Float64, Node{Float64}, @NamedTuple{operators::OperatorEnum{Tuple{typeof(+), typeof(-), typeof(*), typeof(/)}, Tuple{typeof(sin), typeof(cos), typeof(exp)}}, variable_names::Vector{String}}}</code></pre><p>This gives us an easy way to quickly construct expressions with minimal memory overhead, and fast evaluation speed:</p><pre><code class="language-julia hljs">ex = xs[1] * 2.1 - exp(3 * xs[2])</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">(x * 2.1) - exp(3.0 * y)</code></pre><p>Evaluation:</p><pre><code class="language-julia hljs">X = randn(rng, 5, 2)
ex(X)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">2-element Vector{Float64}:
 -2.1202717733478433
 -3.0578777110346</code></pre><p>Or, if we have loaded Zygote, we can differentiate with respect to the variables:</p><pre><code class="language-julia hljs">using Zygote
ex&#39;(X)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">5×2 Matrix{Float64}:
   2.1       2.1
 -13.4623  -12.9587
   0.0       0.0
   0.0       0.0
   0.0       0.0</code></pre><p>Or the constants of the expression:</p><pre><code class="language-julia hljs">ex&#39;(X; variable=Val(false))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">2×2 Matrix{Float64}:
  1.12722   0.600809
 -2.24563  -2.10674</code></pre><p>Which can be used for optimization.</p><hr/><p><em>This page was generated using <a href="https://github.com/fredrikekre/Literate.jl">Literate.jl</a>.</em></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../base_operations/">« Node and Tree Operations</a><a class="docs-footer-nextpage" href="../structured_expression/"><code>StructuredExpression</code> example »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.8.0 on <span class="colophon-date" title="Thursday 6 February 2025 20:43">Thursday 6 February 2025</span>. Using Julia version 1.11.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
