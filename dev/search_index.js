var documenterSearchIndex = {"docs":
[{"location":"api/#API","page":"API","title":"API","text":"","category":"section"},{"location":"api/#Operator-Enum","page":"API","title":"Operator Enum","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"All equations are represented as a tree of operators. Each node in this tree specifies its operator with an integer - which indexes an enum of operators. This enum is defined as follows:","category":"page"},{"location":"api/","page":"API","title":"API","text":"OperatorEnum","category":"page"},{"location":"api/#DynamicExpressions.OperatorEnumModule.OperatorEnum","page":"API","title":"DynamicExpressions.OperatorEnumModule.OperatorEnum","text":"OperatorEnum\n\nDefines an enum over operators, along with their derivatives.\n\nFields\n\nbinops: A tuple of binary operators. Scalar input type.\nunaops: A tuple of unary operators. Scalar input type.\n\n\n\n\n\n","category":"type"},{"location":"api/","page":"API","title":"API","text":"Construct this operator specification as follows:","category":"page"},{"location":"api/","page":"API","title":"API","text":"OperatorEnum(; binary_operators=[], unary_operators=[], define_helper_functions::Bool=true)","category":"page"},{"location":"api/#DynamicExpressions.OperatorEnumModule.OperatorEnum-Tuple{}","page":"API","title":"DynamicExpressions.OperatorEnumModule.OperatorEnum","text":"OperatorEnum(; binary_operators=[], unary_operators=[],\n               define_helper_functions::Bool=true,\n               empty_old_operators::Bool=true)\n\nConstruct an OperatorEnum object, defining the possible expressions. This will also redefine operators for AbstractExpressionNode types, as well as show, print, and (::AbstractExpressionNode)(X). It will automatically compute derivatives with Zygote.jl.\n\nArguments\n\nbinary_operators::Vector{Function}: A vector of functions, each of which is a binary operator.\nunary_operators::Vector{Function}: A vector of functions, each of which is a unary operator.\ndefine_helper_functions::Bool=true: Whether to define helper functions for creating  and evaluating node types. Turn this off when doing precompilation. Note that these  are not needed for the package to work; they are purely for convenience.\nempty_old_operators::Bool=true: Whether to clear the old operators.\n\n\n\n\n\n","category":"method"},{"location":"api/","page":"API","title":"API","text":"This is just for scalar operators. However, you can use the following for more general operators:","category":"page"},{"location":"api/","page":"API","title":"API","text":"GenericOperatorEnum(; binary_operators=[], unary_operators=[], define_helper_functions::Bool=true)","category":"page"},{"location":"api/#DynamicExpressions.OperatorEnumModule.GenericOperatorEnum-Tuple{}","page":"API","title":"DynamicExpressions.OperatorEnumModule.GenericOperatorEnum","text":"GenericOperatorEnum(; binary_operators=[], unary_operators=[],\n                      define_helper_functions::Bool=true, empty_old_operators::Bool=true)\n\nConstruct a GenericOperatorEnum object, defining possible expressions. Unlike OperatorEnum, this enum one will work arbitrary operators and data types. This will also redefine operators for AbstractExpressionNode types, as well as show, print, and (::AbstractExpressionNode)(X).\n\nArguments\n\nbinary_operators::Vector{Function}: A vector of functions, each of which is a binary operator.\nunary_operators::Vector{Function}: A vector of functions, each of which is a unary operator.\ndefine_helper_functions::Bool=true: Whether to define helper functions for creating  and evaluating node types. Turn this off when doing precompilation. Note that these  are not needed for the package to work; they are purely for convenience.\nempty_old_operators::Bool=true: Whether to clear the old operators.\n\n\n\n\n\n","category":"method"},{"location":"api/","page":"API","title":"API","text":"By default, these operators will define helper functions for constructing trees, so that you can write Node(;feature=1) + Node(;feature=2) instead of Node(1, Node(;feature=1), Node(;feature=2)) (assuming + is the first operator). You can turn this off with define_helper_functions=false.","category":"page"},{"location":"api/","page":"API","title":"API","text":"For other operators not found in Base, including user-defined functions, you may use the @extend_operators macro:","category":"page"},{"location":"api/","page":"API","title":"API","text":"@extend_operators operators","category":"page"},{"location":"api/#DynamicExpressions.OperatorEnumConstructionModule.@extend_operators-Tuple{Any}","page":"API","title":"DynamicExpressions.OperatorEnumConstructionModule.@extend_operators","text":"@extend_operators operators [kws...]\n\nExtends all operators defined in this operator enum to work on the Node type. While by default this is already done for operators defined in Base when you create an enum and pass define_helper_functions=true, this does not apply to the user-defined operators. Thus, to do so, you must apply this macro to the operator enum in the same module you have the operators defined.\n\n\n\n\n\n","category":"macro"},{"location":"api/","page":"API","title":"API","text":"This will extend the operators you have passed to work with Node types, so that it is easier to construct expression trees.","category":"page"},{"location":"api/","page":"API","title":"API","text":"Note that you are free to use the Node constructors directly. This is a more robust approach, and should be used when creating libraries which use DynamicExpressions.jl.","category":"page"},{"location":"api/#Nodes","page":"API","title":"Nodes","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Equations are specified as binary trees with the Node type, defined as follows:","category":"page"},{"location":"api/","page":"API","title":"API","text":"Node","category":"page"},{"location":"api/#DynamicExpressions.NodeModule.Node","page":"API","title":"DynamicExpressions.NodeModule.Node","text":"Node{T} <: AbstractExpressionNode{T}\n\nNode defines a symbolic expression stored in a binary tree. A single Node instance is one \"node\" of this tree, and has references to its children. By tracing through the children nodes, you can evaluate or print a given expression.\n\nFields\n\ndegree::UInt8: Degree of the node. 0 for constants, 1 for   unary operators, 2 for binary operators.\nconstant::Bool: Whether the node is a constant.\nval::T: Value of the node. If degree==0, and constant==true,   this is the value of the constant. It has a type specified by the   overall type of the Node (e.g., Float64).\nfeature::UInt16: Index of the feature to use in the   case of a feature node. Only used if degree==0 and constant==false.    Only defined if degree == 0 && constant == false.\nop::UInt8: If degree==1, this is the index of the operator   in operators.unaops. If degree==2, this is the index of the   operator in operators.binops. In other words, this is an enum   of the operators, and is dependent on the specific OperatorEnum   object. Only defined if degree >= 1\nl::Node{T}: Left child of the node. Only defined if degree >= 1.   Same type as the parent node.\nr::Node{T}: Right child of the node. Only defined if degree == 2.   Same type as the parent node. This is to be passed as the right   argument to the binary operator.\n\nConstructors\n\nNode([T]; val=nothing, feature=nothing, op=nothing, l=nothing, r=nothing, children=nothing, allocator=default_allocator)\nNode{T}(; val=nothing, feature=nothing, op=nothing, l=nothing, r=nothing, children=nothing, allocator=default_allocator)\n\nCreate a new node in an expression tree. If T is not specified in either the type or the first argument, it will be inferred from the value of val passed or l and/or r. If it cannot be inferred from these, it will default to Float32.\n\nThe children keyword can be used instead of l and r and should be a tuple of children. This is to permit the use of splatting in constructors.\n\nYou may also construct nodes via the convenience operators generated by creating an OperatorEnum.\n\nYou may also choose to specify a default memory allocator for the node other than simply Node{T}() in the allocator keyword argument.\n\n\n\n\n\n","category":"type"},{"location":"api/","page":"API","title":"API","text":"When you create an Options object, the operators passed are also re-defined for Node types. This allows you use, e.g., t=Node(; feature=1) * 3f0 to create a tree, so long as * was specified as a binary operator.","category":"page"},{"location":"api/","page":"API","title":"API","text":"When using these node constructors, types will automatically be promoted. You can convert the type of a node using convert:","category":"page"},{"location":"api/","page":"API","title":"API","text":"convert(::Type{AbstractExpressionNode{T1}}, tree::AbstractExpressionNode{T2}) where {T1, T2}","category":"page"},{"location":"api/#Base.convert-Union{Tuple{T2}, Tuple{T1}, Tuple{Type{AbstractExpressionNode{T1}}, AbstractExpressionNode{T2}}} where {T1, T2}","page":"API","title":"Base.convert","text":"convert(::Type{<:AbstractExpressionNode{T1}}, n::AbstractExpressionNode{T2}) where {T1,T2}\n\nConvert a AbstractExpressionNode{T2} to a AbstractExpressionNode{T1}. This will recursively convert all children nodes to AbstractExpressionNode{T1}, using convert(T1, tree.val) at constant nodes.\n\nArguments\n\n::Type{AbstractExpressionNode{T1}}: Type to convert to.\ntree::AbstractExpressionNode{T2}: AbstractExpressionNode to convert.\n\n\n\n\n\n","category":"method"},{"location":"api/","page":"API","title":"API","text":"You can set a tree (in-place) with set_node!:","category":"page"},{"location":"api/","page":"API","title":"API","text":"set_node!","category":"page"},{"location":"api/#DynamicExpressions.NodeModule.set_node!","page":"API","title":"DynamicExpressions.NodeModule.set_node!","text":"set_node!(tree::AbstractExpressionNode{T}, new_tree::AbstractExpressionNode{T}) where {T}\n\nSet every field of tree equal to the corresponding field of new_tree.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"You can create a copy of a node with copy_node:","category":"page"},{"location":"api/","page":"API","title":"API","text":"copy_node","category":"page"},{"location":"api/#DynamicExpressions.NodeModule.copy_node","page":"API","title":"DynamicExpressions.NodeModule.copy_node","text":"copy_node(tree::AbstractExpressionNode; break_sharing::Val{BS}=Val(false)) where {BS}\n\nCopy a node, recursively copying all children nodes. This is more efficient than the built-in copy.\n\nIf break_sharing is set to Val(true), sharing in a tree will be ignored.\n\n\n\n\n\n","category":"function"},{"location":"api/#Graph-Nodes","page":"API","title":"Graph Nodes","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"You can describe an equation as a graph rather than a tree by using the GraphNode type:","category":"page"},{"location":"api/","page":"API","title":"API","text":"GraphNode{T}","category":"page"},{"location":"api/#DynamicExpressions.NodeModule.GraphNode","page":"API","title":"DynamicExpressions.NodeModule.GraphNode","text":"GraphNode{T} <: AbstractExpressionNode{T}\n\nExactly the same as Node{T}, but with the assumption that some nodes will be shared. All copies of this graph-like structure will be performed with this assumption, to preserve structure of the graph.\n\nExamples\n\njulia> operators = OperatorEnum(;\n           binary_operators=[+, -, *], unary_operators=[cos, sin]\n        );\n\njulia> x = GraphNode(feature=1)\nx1\n\njulia> y = sin(x) + x\nsin(x1) + {x1}\n\njulia> cos(y) * y\ncos(sin(x1) + {x1}) * {(sin(x1) + {x1})}\n\nNote how the {} indicates a node is shared, and this is the same node as seen earlier in the string.\n\nThis has the same constructors as Node{T}. Shared nodes are created simply by using the same node in multiple places when constructing or setting properties.\n\n\n\n\n\n","category":"type"},{"location":"api/","page":"API","title":"API","text":"This makes it so you can have multiple parents for a given node, and share parts of an expression. For example:","category":"page"},{"location":"api/","page":"API","title":"API","text":"julia> operators = OperatorEnum(;\n           binary_operators=[+, -, *], unary_operators=[cos, sin, exp]\n       );\n\njulia> x1, x2 = GraphNode(feature=1), GraphNode(feature=2)\n(x1, x2)\n\njulia> y = sin(x1) + 1.5\nsin(x1) + 1.5\n\njulia> z = exp(y) + y\nexp(sin(x1) + 1.5) + {(sin(x1) + 1.5)}","category":"page"},{"location":"api/","page":"API","title":"API","text":"Here, the curly braces {} indicate that the node is shared by another (or more) parent node.","category":"page"},{"location":"api/","page":"API","title":"API","text":"This means that we only need to change it once to have changes propagate across the expression:","category":"page"},{"location":"api/","page":"API","title":"API","text":"julia> y.r.val *= 0.9\n1.35\n\njulia> z\nexp(sin(x1) + 1.35) + {(sin(x1) + 1.35)}","category":"page"},{"location":"api/","page":"API","title":"API","text":"This also means there are fewer nodes to describe an expression:","category":"page"},{"location":"api/","page":"API","title":"API","text":"julia> length(z)\n6\n\njulia> length(convert(Node, z))\n10","category":"page"},{"location":"api/","page":"API","title":"API","text":"where we have converted the GraphNode to a Node type, which breaks shared connections into separate nodes.","category":"page"},{"location":"api/#Abstract-Types","page":"API","title":"Abstract Types","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Both the Node and GraphNode types are subtypes of the abstract type:","category":"page"},{"location":"api/","page":"API","title":"API","text":"AbstractExpressionNode{T}","category":"page"},{"location":"api/#DynamicExpressions.NodeModule.AbstractExpressionNode","page":"API","title":"DynamicExpressions.NodeModule.AbstractExpressionNode","text":"AbstractExpressionNode{T} <: AbstractNode\n\nAbstract type for nodes that represent an expression. Along with the fields required for AbstractNode, this additionally must have fields for:\n\nconstant::Bool: Whether the node is a constant.\nval::T: Value of the node. If degree==0, and constant==true,   this is the value of the constant. It has a type specified by the   overall type of the Node (e.g., Float64).\nfeature::UInt16: Index of the feature to use in the   case of a feature node. Only used if degree==0 and constant==false.    Only defined if degree == 0 && constant == false.\nop::UInt8: If degree==1, this is the index of the operator   in operators.unaops. If degree==2, this is the index of the   operator in operators.binops. In other words, this is an enum   of the operators, and is dependent on the specific OperatorEnum   object. Only defined if degree >= 1\n\nInterface\n\nSee NodeInterface for a full description of the interface implementation, as well as tests to verify correctness.\n\nYou must define CustomNode{_T} where {_T} = new{_T}() for each custom node type, as well as constructorof and with_type_parameters.\n\nIn addition, you may choose to define the following functions, to override the defaults behavior, in particular if you wish to add additional fields to your type.\n\nleaf_copy and branch_copy\nleaf_convert and branch_convert\nleaf_equal and branch_equal\nleaf_hash and branch_hash\npreserve_sharing\n\n\n\n\n\n","category":"type"},{"location":"api/","page":"API","title":"API","text":"which can be used to create additional expression-like types. The supertype of this abstract type is the AbstractNode type, which is more generic but does not have all of the same methods:","category":"page"},{"location":"api/","page":"API","title":"API","text":"AbstractNode{T}","category":"page"},{"location":"api/#DynamicExpressions.NodeModule.AbstractNode","page":"API","title":"DynamicExpressions.NodeModule.AbstractNode","text":"AbstractNode\n\nAbstract type for binary trees. Must have the following fields:\n\ndegree::Integer: Degree of the node. Either 0, 1, or 2. If 1,   then l needs to be defined as the left child. If 2,   then r also needs to be defined as the right child.\nl::AbstractNode: Left child of the current node. Should only be   defined if degree >= 1; otherwise, leave it undefined (see the   the constructors of Node{T} for an example).   Don't use nothing to represent an undefined value   as it will incur a large performance penalty.\nr::AbstractNode: Right child of the current node. Should only   be defined if degree == 2.\n\n\n\n\n\n","category":"type"},{"location":"api/#Expressions","page":"API","title":"Expressions","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"A higher-level user-facing type is the Expression:","category":"page"},{"location":"api/","page":"API","title":"API","text":"Expression","category":"page"},{"location":"api/#DynamicExpressions.ExpressionModule.Expression","page":"API","title":"DynamicExpressions.ExpressionModule.Expression","text":"Expression{T, N, D} <: AbstractExpression{T, N}\n\n(Experimental) Defines a high-level, user-facing, expression type that encapsulates an expression tree (like Node) along with associated metadata for evaluation and rendering.\n\nFields\n\ntree::N: The root node of the raw expression tree.\nmetadata::Metadata{D}: A named tuple of settings for the expression,   such as the operators and variable names.\n\nConstructors\n\nExpression(tree::AbstractExpressionNode, metadata::NamedTuple): Construct from the fields\n@parse_expression(expr, operators=operators, variable_names=variable_names, node_type=Node): Parse a Julia expression with a given context and create an Expression object.\n\nUsage\n\nThis type is intended for end-users to interact with and manipulate expressions at a high level, abstracting away the complexities of the underlying expression tree operations.\n\n\n\n\n\n","category":"type"},{"location":"api/","page":"API","title":"API","text":"This is a subtype of AbstractExpression.","category":"page"},{"location":"api/","page":"API","title":"API","text":"AbstractExpression","category":"page"},{"location":"api/#DynamicExpressions.ExpressionModule.AbstractExpression","page":"API","title":"DynamicExpressions.ExpressionModule.AbstractExpression","text":"AbstractExpression{T,N}\n\n(Experimental) Abstract type for user-facing expression types, which contain both the raw expression tree operating on a value type of T, as well as associated metadata to evaluate and render the expression.\n\nSee ExpressionInterface for a full description of the interface implementation, as well as tests to verify correctness.\n\nIf you wish to use @parse_expression, you can also customize the parsing behavior with\n\nparse_leaf\n\n\n\n\n\n","category":"type"},{"location":"api/","page":"API","title":"API","text":"which can be used for defining custom types, such as the ParametricExpression:","category":"page"},{"location":"api/","page":"API","title":"API","text":"ParametricExpression\nParametricNode","category":"page"},{"location":"api/#DynamicExpressions.ParametricExpressionModule.ParametricExpression","page":"API","title":"DynamicExpressions.ParametricExpressionModule.ParametricExpression","text":"ParametricExpression{T,N<:ParametricNode{T},D<:NamedTuple} <: AbstractExpression{T,N}\n\n(Experimental) An expression to store parameters for a tree\n\n\n\n\n\n","category":"type"},{"location":"api/#DynamicExpressions.ParametricExpressionModule.ParametricNode","page":"API","title":"DynamicExpressions.ParametricExpressionModule.ParametricNode","text":"A type of expression node that also stores a parameter index\n\n\n\n\n\n","category":"type"},{"location":"api/","page":"API","title":"API","text":"Another example is the StructuredExpression type, for defining rigid predefined operations in an expression tree:","category":"page"},{"location":"api/","page":"API","title":"API","text":"StructuredExpression","category":"page"},{"location":"api/#DynamicExpressions.StructuredExpressionModule.StructuredExpression","page":"API","title":"DynamicExpressions.StructuredExpressionModule.StructuredExpression","text":"StructuredExpression{T,F,N,E,TS,D} <: AbstractStructuredExpression{T,F,N,E,D} <: AbstractExpression{T,N}\n\nThis expression type allows you to combine multiple expressions together in a predefined way.\n\nParameters\n\nT: The numeric value type of the expressions.\nF: The type of the structure function, which combines each expression into a single expression.\nN: The type of the nodes inside expressions.\nE: The type of the expressions.\nTS: The type of the named tuple containing those inner expressions.\nD: The type of the metadata, another named tuple.\n\nUsage\n\nFor example, we can create two expressions, f, and g, and then combine them together in a new expression, f_plus_g, using a constructor function that simply adds them together:\n\nkws = (;\n    binary_operators=[+, -, *, /],\n    unary_operators=[-, cos, exp],\n    variable_names=[\"x\", \"y\"],\n)\nf = parse_expression(:(x * x - cos(2.5f0 * y + -0.5f0)); kws...)\ng = parse_expression(:(exp(-(y * y))); kws...)\n\nf_plus_g = StructuredExpression((; f, g); structure=nt -> nt.f + nt.g)\n\nNow, when evaluating f_plus_g, this expression type will return the result of adding together the results of f and g.\n\nYou can dispatch on a particular structured expression with the second type parameter, F, which is the function defined above:\n\nmy_factory(nt) = nt.f + nt.g\n\nBase.show(io::IO, e::StructuredExpression{T,typeof(my_factory)}) where {T} = ...\n\nwhich will create a new method particular to this expression type defined on that function.\n\n\n\n\n\n","category":"type"},{"location":"api/","page":"API","title":"API","text":"You may use operators directly on AbstractExpression objects to create a new object containing the combined expression tree, so long as those objects have identical operators in their metadata.","category":"page"},{"location":"api/","page":"API","title":"API","text":"You can extract and set contents and metadata with a few utility functions, including:","category":"page"},{"location":"api/","page":"API","title":"API","text":"get_contents\nwith_contents\nget_metadata\nwith_metadata\nget_tree","category":"page"},{"location":"api/#DynamicExpressions.ExpressionModule.get_contents","page":"API","title":"DynamicExpressions.ExpressionModule.get_contents","text":"get_contents(ex::AbstractExpression)\n\nGet the contents of the expression, which might be a plain AbstractExpressionNode, or some combination of them, or other data. This should include everything other than that returned by get_metadata.\n\n\n\n\n\n","category":"function"},{"location":"api/#DynamicExpressions.ExpressionModule.with_contents","page":"API","title":"DynamicExpressions.ExpressionModule.with_contents","text":"with_contents(ex::AbstractExpression, tree::AbstractExpressionNode)\nwith_contents(ex::AbstractExpression, tree::AbstractExpression)\n\nCreate a new expression based on ex but with a different tree\n\n\n\n\n\n","category":"function"},{"location":"api/#DynamicExpressions.ExpressionModule.get_metadata","page":"API","title":"DynamicExpressions.ExpressionModule.get_metadata","text":"get_metadata(ex::AbstractExpression)\n\nGet the metadata of the expression, which might be a plain NamedTuple, or some combination of them, or other data. This should include everything other than that returned by get_contents.\n\n\n\n\n\n","category":"function"},{"location":"api/#DynamicExpressions.ExpressionModule.with_metadata","page":"API","title":"DynamicExpressions.ExpressionModule.with_metadata","text":"with_metadata(ex::AbstractExpression, metadata)\nwith_metadata(ex::AbstractExpression; metadata...)\n\nCreate a new expression based on ex but with a different metadata.\n\n\n\n\n\n","category":"function"},{"location":"api/#DynamicExpressions.ExpressionModule.get_tree","page":"API","title":"DynamicExpressions.ExpressionModule.get_tree","text":"get_tree(ex::AbstractExpression)\n\nA method that extracts the expression tree from AbstractExpression and should return an AbstractExpressionNode.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"To declare a new operator for expressions, you may use:","category":"page"},{"location":"api/","page":"API","title":"API","text":"@declare_expression_operator","category":"page"},{"location":"api/#DynamicExpressions.ExpressionAlgebraModule.@declare_expression_operator","page":"API","title":"DynamicExpressions.ExpressionAlgebraModule.@declare_expression_operator","text":"@declare_expression_operator(op, arity)\n\nDeclare an operator function for AbstractExpression types.\n\nThis macro generates a method for the given operator op that works with AbstractExpression arguments. The arity parameter specifies whether the operator is unary (1) or binary (2).\n\nArguments\n\nop: The operator to be declared (e.g., Base.sin, Base.:+).\narity: The number of arguments the operator takes (1 for unary, 2 for binary).\n\n\n\n\n\n","category":"macro"},{"location":"api/#Interfaces","page":"API","title":"Interfaces","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"The interfaces for AbstractExpression and AbstractExpressionNode are tested using Interfaces.jl. You can see the interfaces with:","category":"page"},{"location":"api/","page":"API","title":"API","text":"DynamicExpressions.ExpressionInterface\nDynamicExpressions.NodeInterface","category":"page"},{"location":"api/#DynamicExpressions.InterfacesModule.ExpressionInterface","page":"API","title":"DynamicExpressions.InterfacesModule.ExpressionInterface","text":"    ExpressionInterface\n\nAn Interfaces.jl Interface with mandatory components (:get_contents, :get_metadata, :get_tree, :get_operators, :get_variable_names, :copy, :with_contents, :with_metadata) and optional components (:copy_into!, :count_nodes, :count_constant_nodes, :count_depth, :index_constant_nodes, :has_operators, :has_constants, :get_scalar_constants, :set_scalar_constants!, :string_tree, :default_node_type, :constructorof, :tree_mapreduce).\n\nDefines the interface of AbstractExpression for user-facing expression types, which can store operators, extra parameters, functional forms, variable names, etc.\n\nExtended help\n\nMandatory keys:\n\nget_contents: extracts the runtime contents of an expression\nget_metadata: extracts the runtime metadata of an expression\nget_tree: extracts the expression tree from AbstractExpression\nget_operators: returns the operators used in the expression (or pass operators explicitly to override)\nget_variable_names: returns the variable names used in the expression (or pass variable_names explicitly to override)\ncopy: returns a copy of the expression\nwith_contents: returns the expression with different tree\nwith_metadata: returns the expression with different metadata\n\nOptional keys:\n\ncopy_into!: copies an expression into a preallocated container\ncount_nodes: counts the number of nodes in the expression tree\ncount_constant_nodes: counts the number of constant nodes in the expression tree\ncount_depth: calculates the depth of the expression tree\nindex_constant_nodes: indexes constants in the expression tree\nhas_operators: checks if the expression has operators\nhas_constants: checks if the expression has constants\nget_scalar_constants: gets constants from the expression tree, returning a tuple of: (1) a flat vector of the constants, and (2) an reference object that can be used by set_scalar_constants! to efficiently set them back\nset_scalar_constants!: sets constants in the expression tree, given: (1) a flat vector of constants, (2) the expression, and (3) the reference object produced by get_scalar_constants\nstring_tree: returns a string representation of the expression tree\ndefault_node_type: returns the default node type for the expression\nconstructorof: gets the constructor function for a type\ntree_mapreduce: applies a function across the tree\n\n\n\n\n\n","category":"type"},{"location":"api/#DynamicExpressions.InterfacesModule.NodeInterface","page":"API","title":"DynamicExpressions.InterfacesModule.NodeInterface","text":"    NodeInterface\n\nAn Interfaces.jl Interface with mandatory components (:create_node, :copy, :hash, :any, :equality, :preserve_sharing, :constructorof, :eltype, :with_type_parameters, :default_allocator, :set_node!, :count_nodes, :tree_mapreduce) and optional components (:copy_into!, :leaf_copy, :leaf_copy_into!, :leaf_convert, :leaf_hash, :leaf_equal, :branch_copy, :branch_copy_into!, :branch_convert, :branch_hash, :branch_equal, :count_depth, :is_node_constant, :count_constant_nodes, :filter_map, :has_constants, :get_scalar_constants, :set_scalar_constants!, :index_constant_nodes, :has_operators).\n\nDefines the interface for AbstractExpressionNode which can include various operations such as copying, hashing, and checking equality, as well as tree-specific operations like map-reduce and node manipulation.\n\nExtended help\n\nMandatory keys:\n\ncreate_node: creates a new instance of the node type\ncopy: returns a copy of the tree\nhash: returns the hash of the tree\nany: checks if any element of the tree satisfies a condition\nequality: checks equality of the tree with itself and its copy\npreserve_sharing: checks if the node type preserves sharing\nconstructorof: gets the constructor function for a node type\neltype: gets the element type of the node\nwith_type_parameters: applies type parameters to the node type\ndefault_allocator: gets the default allocator for the node type\nset_node!: sets the node's value\ncount_nodes: counts the number of nodes in the tree\ntree_mapreduce: applies a function across the tree\n\nOptional keys:\n\ncopy_into!: copies a node into a preallocated container\nleaf_copy: copies a leaf node\nleaf_copy_into!: copies a leaf node in-place\nleaf_convert: converts a leaf node\nleaf_hash: computes the hash of a leaf node\nleaf_equal: checks equality of two leaf nodes\nbranch_copy: copies a branch node\nbranch_copy_into!: copies a branch node in-place\nbranch_convert: converts a branch node\nbranch_hash: computes the hash of a branch node\nbranch_equal: checks equality of two branch nodes\ncount_depth: calculates the depth of the tree\nis_node_constant: checks if the node is a constant\ncount_constant_nodes: counts the number of constant nodes\nfilter_map: applies a filter and map function to the tree\nhas_constants: checks if the tree has constants\nget_scalar_constants: gets constants from the tree, returning a tuple of: (1) a flat vector of the constants, and (2) a reference object that can be used by set_scalar_constants! to efficiently set them back\nset_scalar_constants!: sets constants in the tree, given: (1) a flat vector of constants, (2) the tree, and (3) the reference object produced by get_scalar_constants\nindex_constant_nodes: indexes constants in the tree\nhas_operators: checks if the tree has operators\n\n\n\n\n\n","category":"type"},{"location":"api/","page":"API","title":"API","text":"You can declare a new type as implementing these with, e.g.,","category":"page"},{"location":"api/","page":"API","title":"API","text":"using DynamicExpressions: ExpressionInterface, all_ei_methods_except\nusing Interface: @implements, Arguments, Interface\n\n# Add all optional methods:\nvalid_optional_methods = all_ei_methods_except(())\n\n@implements ExpressionInterface{valid_optional_methods} MyCustomExpression [Arguments()]","category":"page"},{"location":"api/","page":"API","title":"API","text":"You can then test the interface is implemented correctly using, for example,","category":"page"},{"location":"api/","page":"API","title":"API","text":"@test Interface.test(ExpressionInterface, MyCustomExpression, [ex::MyCustomExpression])","category":"page"},{"location":"api/","page":"API","title":"API","text":"Note that this may not flag all potential issues, so be sure to still read the details about what methods can be implemented and customized.","category":"page"},{"location":"eval/#Evaluation-and-Derivatives","page":"Eval","title":"Evaluation & Derivatives","text":"","category":"section"},{"location":"eval/#Evaluation","page":"Eval","title":"Evaluation","text":"","category":"section"},{"location":"eval/","page":"Eval","title":"Eval","text":"Given an expression tree specified with a Node type, you may evaluate the expression over an array of data with the following command:","category":"page"},{"location":"eval/","page":"Eval","title":"Eval","text":"eval_tree_array(\n    tree::AbstractExpressionNode{T},\n    cX::AbstractMatrix{T},\n    operators::OperatorEnum;\n    eval_options::Union{EvalOptions,Nothing}=nothing,\n) where {T}","category":"page"},{"location":"eval/#DynamicExpressions.EvaluateModule.eval_tree_array-Union{Tuple{T}, Tuple{AbstractExpressionNode{T}, AbstractMatrix{T}, OperatorEnum}} where T","page":"Eval","title":"DynamicExpressions.EvaluateModule.eval_tree_array","text":"eval_tree_array(\n    tree::AbstractExpressionNode{T},\n    cX::AbstractMatrix{T},\n    operators::OperatorEnum;\n    eval_options::Union{EvalOptions,Nothing}=nothing,\n) where {T}\n\nEvaluate a binary tree (equation) over a given input data matrix. The operators contain all of the operators used. This function fuses doublets and triplets of operations for lower memory usage.\n\nArguments\n\ntree::AbstractExpressionNode: The root node of the tree to evaluate.\ncX::AbstractMatrix{T}: The input data to evaluate the tree on, with shape [num_features, num_rows].\noperators::OperatorEnum: The operators used in the tree.\neval_options::Union{EvalOptions,Nothing}: See EvalOptions for documentation   on the different evaluation modes.\n\nReturns\n\n(output, complete)::Tuple{AbstractVector{T}, Bool}: the result,   which is a 1D array, as well as if the evaluation completed   successfully (true/false). A false complete means an infinity   or nan was encountered, and a large loss should be assigned   to the equation.\n\nNotes\n\nThis function can be represented by the following pseudocode:\n\ndef eval(current_node)\n    if current_node is leaf\n        return current_node.value\n    elif current_node is degree 1\n        return current_node.operator(eval(current_node.left_child))\n    else\n        return current_node.operator(eval(current_node.left_child), eval(current_node.right_child))\n\nThe bulk of the code is for optimizations and pre-emptive NaN/Inf checks, which speed up evaluation significantly.\n\n\n\n\n\n","category":"method"},{"location":"eval/","page":"Eval","title":"Eval","text":"You can also use the following shorthand by using the expression as a function:","category":"page"},{"location":"eval/","page":"Eval","title":"Eval","text":"    (tree::AbstractExpressionNode)(X, operators::OperatorEnum; kws...)\n\nEvaluate a binary tree (equation) over a given input data matrix. The\noperators contain all of the operators used. This function fuses doublets\nand triplets of operations for lower memory usage.\n\n# Arguments\n- `tree::AbstractExpressionNode`: The root node of the tree to evaluate.\n- `cX::AbstractMatrix{T}`: The input data to evaluate the tree on.\n- `operators::OperatorEnum`: The operators used in the tree.\n- `kws...`: Passed to [`eval_tree_array`](@ref).\n\n# Returns\n- `output::AbstractVector{T}`: the result, which is a 1D array.\n    Any NaN, Inf, or other failure during the evaluation will result in the entire\n    output array being set to NaN.","category":"page"},{"location":"eval/","page":"Eval","title":"Eval","text":"For example,","category":"page"},{"location":"eval/","page":"Eval","title":"Eval","text":"using DynamicExpressions\n\noperators = OperatorEnum(; binary_operators=[+, -, *], unary_operators=[cos])\ntree = Node(; feature=1) * cos(Node(; feature=2) - 3.2)\n\ntree([1 2 3; 4 5 6.], operators)","category":"page"},{"location":"eval/","page":"Eval","title":"Eval","text":"This is possible because when you call OperatorEnum, it automatically re-defines (::Node)(X) to call the evaluation operation with the given operators loaded. It also re-defines print, show, and the various operators, to work with the Node type.","category":"page"},{"location":"eval/","page":"Eval","title":"Eval","text":"warning: Warning\nThe Node type does not know about which OperatorEnum you used to create it. Thus, if you define an expression with one OperatorEnum, and then try to evaluate it or print it with a different OperatorEnum, you will get undefined behavior!For safer behavior, you should use Expression objects.","category":"page"},{"location":"eval/","page":"Eval","title":"Eval","text":"Evaluation options are specified using EvalOptions:","category":"page"},{"location":"eval/","page":"Eval","title":"Eval","text":"EvalOptions","category":"page"},{"location":"eval/#DynamicExpressions.EvaluateModule.EvalOptions","page":"Eval","title":"DynamicExpressions.EvaluateModule.EvalOptions","text":"EvalOptions\n\nThis holds options for expression evaluation, such as evaluation backend.\n\nFields\n\nturbo::Val{T}=Val(false): If Val{true}, use LoopVectorization.jl for faster   evaluation.\nbumper::Val{B}=Val(false): If Val{true}, use Bumper.jl for faster evaluation.\nearly_exit::Val{E}=Val(true): If Val{true}, any element of any step becoming   NaN or Inf will terminate the computation. For eval_tree_array, this will   result in the second return value, the completion flag, being false. For    calling an expression using tree(X), this will result in NaNs filling   the entire buffer. This early exit is performed to avoid wasting compute cycles.   Setting Val{false} will continue the computation as usual and thus result in   NaNs only in the elements that actually have NaNs.\nbuffer::Union{ArrayBuffer,Nothing}: If not nothing, use this buffer for evaluation.   This should be an instance of ArrayBuffer which has an array field and an   index field used to iterate which buffer slot to use.\n\n\n\n\n\n","category":"type"},{"location":"eval/","page":"Eval","title":"Eval","text":"You can also work with arbitrary types, by defining a GenericOperatorEnum instead. The notation is the same for eval_tree_array, though it will return nothing when it can't find a method, and not do any NaN checks:","category":"page"},{"location":"eval/","page":"Eval","title":"Eval","text":"eval_tree_array(tree::Node, cX::AbstractMatrix, operators::GenericOperatorEnum; throw_errors::Bool=true)","category":"page"},{"location":"eval/#DynamicExpressions.EvaluateModule.eval_tree_array-Tuple{Node, AbstractMatrix, GenericOperatorEnum}","page":"Eval","title":"DynamicExpressions.EvaluateModule.eval_tree_array","text":"eval_tree_array(tree::AbstractExpressionNode, cX::AbstractMatrix, operators::GenericOperatorEnum; throw_errors::Bool=true)\n\nEvaluate a generic binary tree (equation) over a given input data, whatever that input data may be. The operators enum contains all of the operators used. Unlike eval_tree_array with the normal OperatorEnum, the array cX is sliced only along the first dimension. i.e., if cX is a vector, then the output of a feature node will be a scalar. If cX is a 3D tensor, then the output of a feature node will be a 2D tensor. Note also that tree.feature will index along the first axis of cX.\n\nHowever, there is no requirement about input and output types in general. You may set up your tree such that some operator nodes work on tensors, while other operator nodes work on scalars. eval_tree_array will simply return nothing if a given operator is not defined for the given input type.\n\nThis function can be represented by the following pseudocode:\n\nfunction eval(current_node)\n    if current_node is leaf\n        return current_node.value\n    elif current_node is degree 1\n        return current_node.operator(eval(current_node.left_child))\n    else\n        return current_node.operator(eval(current_node.left_child), eval(current_node.right_child))\n\nArguments\n\ntree::AbstractExpressionNode: The root node of the tree to evaluate.\ncX::AbstractArray: The input data to evaluate the tree on.\noperators::GenericOperatorEnum: The operators used in the tree.\nthrow_errors::Bool=true: Whether to throw errors   if they occur during evaluation. Otherwise,   MethodErrors will be caught before they happen and    evaluation will return nothing,   rather than throwing an error. This is useful in cases   where you are unsure if a particular tree is valid or not,   and would prefer to work with nothing as an output.\n\nReturns\n\n(output, complete)::Tuple{Any, Bool}: the result,   as well as if the evaluation completed successfully (true/false).   If evaluation failed, nothing will be returned for the first argument.   A false complete means an operator was called on input types   that it was not defined for.\n\n\n\n\n\n","category":"method"},{"location":"eval/","page":"Eval","title":"Eval","text":"Likewise for the shorthand notation:","category":"page"},{"location":"eval/","page":"Eval","title":"Eval","text":"    (tree::Node)(X::AbstractMatrix, operators::GenericOperatorEnum; throw_errors::Bool=true)\n\n# Arguments\n- `X::AbstractArray`: The input data to evaluate the tree on.\n- `operators::GenericOperatorEnum`: The operators used in the tree.\n- `throw_errors::Bool=true`: Whether to throw errors\n    if they occur during evaluation. Otherwise,\n    MethodErrors will be caught before they happen and\n    evaluation will return `nothing`,\n    rather than throwing an error. This is useful in cases\n    where you are unsure if a particular tree is valid or not,\n    and would prefer to work with `nothing` as an output.\n\n# Returns\n- `output`: the result of the evaluation.\n    If evaluation failed, `nothing` will be returned for the first argument.\n    A `false` complete means an operator was called on input types\n    that it was not defined for. You can change this behavior by\n    setting `throw_errors=false`.","category":"page"},{"location":"eval/#Derivatives","page":"Eval","title":"Derivatives","text":"","category":"section"},{"location":"eval/","page":"Eval","title":"Eval","text":"DynamicExpressions.jl can efficiently compute first-order derivatives of expressions with respect to variables or constants. This is done using either eval_diff_tree_array, to compute derivative with respect to a single variable, or with eval_grad_tree_array, to compute the gradient with respect all variables (or, all constants). Both use forward-mode automatic, but use Zygote.jl to compute derivatives of each operator, so this is very efficient.","category":"page"},{"location":"eval/","page":"Eval","title":"Eval","text":"eval_diff_tree_array(tree::Node{T}, cX::AbstractMatrix{T}, operators::OperatorEnum, direction::Integer) where {T<:Number}\neval_grad_tree_array(tree::Node{T}, cX::AbstractMatrix{T}, operators::OperatorEnum) where {T<:Number}","category":"page"},{"location":"eval/#DynamicExpressions.EvaluateDerivativeModule.eval_diff_tree_array-Union{Tuple{T}, Tuple{Node{T}, AbstractMatrix{T}, OperatorEnum, Integer}} where T<:Number","page":"Eval","title":"DynamicExpressions.EvaluateDerivativeModule.eval_diff_tree_array","text":"eval_diff_tree_array(\n    tree::AbstractExpressionNode{T},\n    cX::AbstractMatrix{T},\n    operators::OperatorEnum,\n    direction::Integer;\n    turbo::Union{Bool,Val}=Val(false)\n) where {T<:Number}\n\nCompute the forward derivative of an expression, using a similar structure and optimization to evaltreearray. direction is the index of a particular variable in the expression. e.g., direction=1 would indicate derivative with respect to x1.\n\nArguments\n\ntree::AbstractExpressionNode: The expression tree to evaluate.\ncX::AbstractMatrix{T}: The data matrix, with shape [num_features, num_rows].\noperators::OperatorEnum: The operators used to create the tree.\ndirection::Integer: The index of the variable to take the derivative with respect to.\nturbo::Union{Bool,Val}: Use LoopVectorization.jl for faster evaluation. Currently this does not have   any effect.\n\nReturns\n\n(evaluation, derivative, complete)::Tuple{AbstractVector{T}, AbstractVector{T}, Bool}: the normal evaluation,   the derivative, and whether the evaluation completed as normal (or encountered a nan or inf).\n\n\n\n\n\n","category":"method"},{"location":"eval/#DynamicExpressions.EvaluateDerivativeModule.eval_grad_tree_array-Union{Tuple{T}, Tuple{Node{T}, AbstractMatrix{T}, OperatorEnum}} where T<:Number","page":"Eval","title":"DynamicExpressions.EvaluateDerivativeModule.eval_grad_tree_array","text":"eval_grad_tree_array(tree::AbstractExpressionNode{T}, cX::AbstractMatrix{T}, operators::OperatorEnum; variable::Union{Bool,Val}=Val(false), turbo::Union{Bool,Val}=Val(false))\n\nCompute the forward-mode derivative of an expression, using a similar structure and optimization to evaltreearray. variable specifies whether we should take derivatives with respect to features (i.e., cX), or with respect to every constant in the expression.\n\nArguments\n\ntree::AbstractExpressionNode{T}: The expression tree to evaluate.\ncX::AbstractMatrix{T}: The data matrix, with each column being a data point.\noperators::OperatorEnum: The operators used to create the tree.\nvariable::Union{Bool,Val}: Whether to take derivatives with respect to features (i.e., cX - with variable=true),   or with respect to every constant in the expression (variable=false).\nturbo::Union{Bool,Val}: Use LoopVectorization.jl for faster evaluation. Currently this does not have   any effect.\n\nReturns\n\n(evaluation, gradient, complete)::Tuple{AbstractVector{T}, AbstractMatrix{T}, Bool}: the normal evaluation,   the gradient, and whether the evaluation completed as normal (or encountered a nan or inf).\n\n\n\n\n\n","category":"method"},{"location":"eval/","page":"Eval","title":"Eval","text":"You can compute gradients this with shorthand notation as well (which by default computes gradients with respect to input matrix, rather than constants).","category":"page"},{"location":"eval/","page":"Eval","title":"Eval","text":"    (tree::Node{T})'(X::AbstractMatrix{T}, operators::OperatorEnum; turbo::Bool=false, variable::Bool=true)\n\nCompute the forward-mode derivative of an expression, using a similar\nstructure and optimization to eval_tree_array. `variable` specifies whether\nwe should take derivatives with respect to features (i.e., X), or with respect\nto every constant in the expression.\n\n# Arguments\n- `X::AbstractMatrix{T}`: The data matrix, with each column being a data point.\n- `operators::OperatorEnum`: The operators used to create the `tree`.\n- `variable::Bool`: Whether to take derivatives with respect to features (i.e., `X` - with `variable=true`),\n    or with respect to every constant in the expression (`variable=false`).\n- `turbo::Bool`: Use `LoopVectorization.@turbo` for faster evaluation.\n\n# Returns\n\n- `(evaluation, gradient, complete)::Tuple{AbstractVector{T}, AbstractMatrix{T}, Bool}`: the normal evaluation,\n    the gradient, and whether the evaluation completed as normal (or encountered a nan or inf).","category":"page"},{"location":"eval/","page":"Eval","title":"Eval","text":"Alternatively, you can compute higher-order derivatives by using ForwardDiff on the function differentiable_eval_tree_array, although this will be slower.","category":"page"},{"location":"eval/","page":"Eval","title":"Eval","text":"differentiable_eval_tree_array(tree::Node{T}, cX::AbstractMatrix{T}, operators::OperatorEnum) where {T<:Number}","category":"page"},{"location":"eval/#DynamicExpressions.EvaluateModule.differentiable_eval_tree_array-Union{Tuple{T}, Tuple{Node{T}, AbstractMatrix{T}, OperatorEnum}} where T<:Number","page":"Eval","title":"DynamicExpressions.EvaluateModule.differentiable_eval_tree_array","text":"differentiable_eval_tree_array(tree::AbstractExpressionNode, cX::AbstractMatrix, operators::OperatorEnum)\n\nEvaluate an expression tree in a way that can be auto-differentiated.\n\n\n\n\n\n","category":"method"},{"location":"eval/#Enzyme","page":"Eval","title":"Enzyme","text":"","category":"section"},{"location":"eval/","page":"Eval","title":"Eval","text":"DynamicExpressions.jl also supports automatic differentiation with Enzyme.jl. Note that this is extremely experimental. You should expect to see occasional incorrect gradients. Be sure to explicitly verify gradients are correct for a particular space of operators (e.g., with finite differences).","category":"page"},{"location":"eval/","page":"Eval","title":"Eval","text":"Let's look at an example. First, let's create a tree:","category":"page"},{"location":"eval/","page":"Eval","title":"Eval","text":"using DynamicExpressions\n\noperators = OperatorEnum(binary_operators=(+, -, *, /), unary_operators=(cos, sin))\n\nx1 = Node{Float64}(feature=1)\nx2 = Node{Float64}(feature=2)\n\ntree = 0.5 * x1 + cos(x2 - 0.2)","category":"page"},{"location":"eval/","page":"Eval","title":"Eval","text":"Now, say we want to take the derivative of this expression with respect to x1 and x2. First, let's evaluate it normally:","category":"page"},{"location":"eval/","page":"Eval","title":"Eval","text":"X = [1.0 2.0 3.0; 4.0 5.0 6.0]  # 2x3 matrix (2 features, 3 rows)\n\ntree(X, operators)","category":"page"},{"location":"eval/","page":"Eval","title":"Eval","text":"Now, let's use Enzyme.jl to compute the derivative of the outputs with respect to x1 and x2, using reverse-mode autodiff:","category":"page"},{"location":"eval/","page":"Eval","title":"Eval","text":"using Enzyme\n\nfunction my_loss_function(tree, X, operators)\n    # Get the outputs\n    y = tree(X, operators)\n    # Sum them (so we can take a gradient, rather than a jacobian)\n    return sum(y)\nend\n\n\ndX = begin\n    storage=zero(X)\n    autodiff(\n        Reverse,\n        my_loss_function,\n        Active,\n        ## Actual arguments to function:\n        Const(tree),\n        Duplicated(X, storage),\n        Const(operators),\n    )\n    storage\nend","category":"page"},{"location":"eval/","page":"Eval","title":"Eval","text":"This will get returned as","category":"page"},{"location":"eval/","page":"Eval","title":"Eval","text":" 2×3 Matrix{Float64}:\n  0.5       0.5       0.5\n  0.611858  0.996165  0.464602","category":"page"},{"location":"eval/","page":"Eval","title":"Eval","text":"which one can confirm is the correct gradient!","category":"page"},{"location":"eval/","page":"Eval","title":"Eval","text":"This will take a while the first time you run it, as Enzyme needs to take the gradients of the actual LLVM IR code. Subsequent runs won't spend any time compiling and be much faster.","category":"page"},{"location":"eval/","page":"Eval","title":"Eval","text":"Some general notes about this:","category":"page"},{"location":"eval/","page":"Eval","title":"Eval","text":"We want to take a reverse-mode gradient, so we pass Reverse to autodiff.\nSince we want to take the gradient of the output of my_loss_function, we declare Active as the third argument.\nFollowing this, we pass our actual arguments to the function.\nObjects which we don't want to take gradients with respect to,  and also don't temporarily store any data during the computation  (such as tree and operators here) should be wrapped with Const.\nObjects which we wish to take derivatives with respect to, we need to use   Duplicated, and explicitly create a copy of it, with all numerical values   set to zero. Enzyme will then store the derivatives in this object.","category":"page"},{"location":"eval/","page":"Eval","title":"Eval","text":"Note that you should never use anything other than turbo=Val(false) with Enzyme, as Enzyme and LoopVectorization are not compatible, and will cause a segfault. Even using turbo=false will not work, because it would cause Enzyme to trace the (unused) LoopVectorization code!","category":"page"},{"location":"examples/base_operations/","page":"Node and Tree Operations","title":"Node and Tree Operations","text":"EditURL = \"../../../test/test_base_2.jl\"","category":"page"},{"location":"examples/base_operations/#Node-and-Tree-Operations","page":"Node and Tree Operations","title":"Node and Tree Operations","text":"","category":"section"},{"location":"examples/base_operations/","page":"Node and Tree Operations","title":"Node and Tree Operations","text":"This example demonstrates how to create and manipulate expression trees using the Node type.","category":"page"},{"location":"examples/base_operations/","page":"Node and Tree Operations","title":"Node and Tree Operations","text":"First, let's create a node to reference feature=1 of our dataset:","category":"page"},{"location":"examples/base_operations/","page":"Node and Tree Operations","title":"Node and Tree Operations","text":"using DynamicExpressions, Random\n\nx = Node{Float64}(; feature=1)","category":"page"},{"location":"examples/base_operations/","page":"Node and Tree Operations","title":"Node and Tree Operations","text":"We can also create values, using val:","category":"page"},{"location":"examples/base_operations/","page":"Node and Tree Operations","title":"Node and Tree Operations","text":"const_1 = Node{Float64}(; val=1.0)","category":"page"},{"location":"examples/base_operations/","page":"Node and Tree Operations","title":"Node and Tree Operations","text":"Now, let's declare some operators to use in our expression tree.","category":"page"},{"location":"examples/base_operations/","page":"Node and Tree Operations","title":"Node and Tree Operations","text":"Note that the declaration of the OperatorEnum updates a global mapping from operators to their index in a list. This is purely for convenience, and most of the time, you would either operate directly on the OperatorEnum, like with eval_tree_array, or use Expression objects to store them alongside the expression.","category":"page"},{"location":"examples/base_operations/","page":"Node and Tree Operations","title":"Node and Tree Operations","text":"operators = OperatorEnum(; unary_operators=(sin, exp), binary_operators=(+, -, *, /))","category":"page"},{"location":"examples/base_operations/","page":"Node and Tree Operations","title":"Node and Tree Operations","text":"Now, let's create another variable","category":"page"},{"location":"examples/base_operations/","page":"Node and Tree Operations","title":"Node and Tree Operations","text":"y = Node{Float64}(; feature=2)","category":"page"},{"location":"examples/base_operations/","page":"Node and Tree Operations","title":"Node and Tree Operations","text":"And we can now create expression trees:","category":"page"},{"location":"examples/base_operations/","page":"Node and Tree Operations","title":"Node and Tree Operations","text":"tree = (x + y) * const_1 - sin(x)","category":"page"},{"location":"examples/base_operations/","page":"Node and Tree Operations","title":"Node and Tree Operations","text":"The type of this is the same as the type of the variables and constants, meaning we have type stability:","category":"page"},{"location":"examples/base_operations/","page":"Node and Tree Operations","title":"Node and Tree Operations","text":"typeof(tree), typeof(x)","category":"page"},{"location":"examples/base_operations/","page":"Node and Tree Operations","title":"Node and Tree Operations","text":"We can also just use scalars directly:","category":"page"},{"location":"examples/base_operations/","page":"Node and Tree Operations","title":"Node and Tree Operations","text":"tree2 = 2x - sin(x)","category":"page"},{"location":"examples/base_operations/","page":"Node and Tree Operations","title":"Node and Tree Operations","text":"As you have noticed, the tree is printed as an expression. We can control this with the string_tree function, which also lets us pass the operators explicitly:","category":"page"},{"location":"examples/base_operations/","page":"Node and Tree Operations","title":"Node and Tree Operations","text":"string_tree(tree, operators; variable_names=[\"x\", \"y\"])","category":"page"},{"location":"examples/base_operations/","page":"Node and Tree Operations","title":"Node and Tree Operations","text":"This also lets us control how each branch node and leaf node (variable/constant) is printed in the tree.","category":"page"},{"location":"examples/base_operations/","page":"Node and Tree Operations","title":"Node and Tree Operations","text":"There are a lot of operations you can do on tree objects, such as evaluating them over batched data:","category":"page"},{"location":"examples/base_operations/","page":"Node and Tree Operations","title":"Node and Tree Operations","text":"rng = Random.MersenneTwister(0)\ntree2(randn(rng, Float64, 2, 5), operators)","category":"page"},{"location":"examples/base_operations/","page":"Node and Tree Operations","title":"Node and Tree Operations","text":"Now, how does this actually work? How do these functions traverse the tree?","category":"page"},{"location":"examples/base_operations/","page":"Node and Tree Operations","title":"Node and Tree Operations","text":"The core operation is the tree_mapreduce function, which applies a function to each node in the tree, and then combines the results. Unlike a standard mapreduce, the tree_mapreduce allows you to specify different maps for branch nodes and leaf nodes. Also unlike a mapreduce, the reduction function needs to handle a variable number of inputs – it takes the mapped branch node, as well as all of the mapped children.","category":"page"},{"location":"examples/base_operations/","page":"Node and Tree Operations","title":"Node and Tree Operations","text":"Let's see an example. Say we just want to count the nodes in the tree:","category":"page"},{"location":"examples/base_operations/","page":"Node and Tree Operations","title":"Node and Tree Operations","text":"num_nodes = tree_mapreduce(node -> 1, +, tree)","category":"page"},{"location":"examples/base_operations/","page":"Node and Tree Operations","title":"Node and Tree Operations","text":"Here, the + handles both the cases of 1 child and 2 children. Here, we didn't need to specify a custom branch function, but we could do that too:","category":"page"},{"location":"examples/base_operations/","page":"Node and Tree Operations","title":"Node and Tree Operations","text":"num_leafs = tree_mapreduce(leaf_node -> 1, branch_node -> 0, +, tree)","category":"page"},{"location":"examples/base_operations/","page":"Node and Tree Operations","title":"Node and Tree Operations","text":"This counts the number of leaf nodes in the tree. For tree, this was x, y, const_1, and x.","category":"page"},{"location":"examples/base_operations/","page":"Node and Tree Operations","title":"Node and Tree Operations","text":"You can access fields of the Node type here to create more complex operations, just be careful to not access undefined fields (be sure to read the API specification).","category":"page"},{"location":"examples/base_operations/","page":"Node and Tree Operations","title":"Node and Tree Operations","text":"Most operators can be built with this simple pattern, even including evaluation of the tree, and printing of expressions. (It also allows for graph-like expressions like GraphNode via a f_on_shared keyword.)","category":"page"},{"location":"examples/base_operations/","page":"Node and Tree Operations","title":"Node and Tree Operations","text":"As a more complex example, let's compute the depth of a tree. Here, we need to use a more complicated reduction operation – the max:","category":"page"},{"location":"examples/base_operations/","page":"Node and Tree Operations","title":"Node and Tree Operations","text":"depth = tree_mapreduce(\n    node -> 1, (parent, children...) -> 1 + max(children...), x + sin(sin(exp(x)))\n)","category":"page"},{"location":"examples/base_operations/","page":"Node and Tree Operations","title":"Node and Tree Operations","text":"Here, the max handles both the cases of 1 child and 2 children. The parent node contributes 1 at each depth. Note that the inputs to the reduction are already mapped to 1.","category":"page"},{"location":"examples/base_operations/","page":"Node and Tree Operations","title":"Node and Tree Operations","text":"Many operations do not need to handle branching, and thus, many of the typical operations on collections in Julia are available. For example, we can collect each node in the tree into a list:","category":"page"},{"location":"examples/base_operations/","page":"Node and Tree Operations","title":"Node and Tree Operations","text":"collect(tree)","category":"page"},{"location":"examples/base_operations/","page":"Node and Tree Operations","title":"Node and Tree Operations","text":"Note that the first node in this list is the root note, which is the subtraction operation:","category":"page"},{"location":"examples/base_operations/","page":"Node and Tree Operations","title":"Node and Tree Operations","text":"tree == first(collect(tree))","category":"page"},{"location":"examples/base_operations/","page":"Node and Tree Operations","title":"Node and Tree Operations","text":"We can look at the operator:","category":"page"},{"location":"examples/base_operations/","page":"Node and Tree Operations","title":"Node and Tree Operations","text":"tree.degree, tree.op","category":"page"},{"location":"examples/base_operations/","page":"Node and Tree Operations","title":"Node and Tree Operations","text":"And compare it to our list:","category":"page"},{"location":"examples/base_operations/","page":"Node and Tree Operations","title":"Node and Tree Operations","text":"operators.binops","category":"page"},{"location":"examples/base_operations/","page":"Node and Tree Operations","title":"Node and Tree Operations","text":"Many other collection operations are available. For example, we can aggregate a relationship over each node:","category":"page"},{"location":"examples/base_operations/","page":"Node and Tree Operations","title":"Node and Tree Operations","text":"sum(node -> node.degree == 0 ? 1.5 : 0.0, tree)","category":"page"},{"location":"examples/base_operations/","page":"Node and Tree Operations","title":"Node and Tree Operations","text":"We can even use any which has an early exit from the depth-first tree traversal:","category":"page"},{"location":"examples/base_operations/","page":"Node and Tree Operations","title":"Node and Tree Operations","text":"any(node -> node.degree == 2, tree)","category":"page"},{"location":"examples/base_operations/","page":"Node and Tree Operations","title":"Node and Tree Operations","text":"We can also randomly sample nodes, using NodeSampler, which permits filters:","category":"page"},{"location":"examples/base_operations/","page":"Node and Tree Operations","title":"Node and Tree Operations","text":"rand(rng, NodeSampler(; tree, filter=node -> node.degree == 1))","category":"page"},{"location":"examples/base_operations/","page":"Node and Tree Operations","title":"Node and Tree Operations","text":"","category":"page"},{"location":"examples/base_operations/","page":"Node and Tree Operations","title":"Node and Tree Operations","text":"This page was generated using Literate.jl.","category":"page"},{"location":"examples/structured_expression/","page":"StructuredExpression example","title":"StructuredExpression example","text":"EditURL = \"../../../test/test_structured_expression.jl\"","category":"page"},{"location":"examples/structured_expression/#StructuredExpression-example","page":"StructuredExpression example","title":"StructuredExpression example","text":"","category":"section"},{"location":"examples/structured_expression/","page":"StructuredExpression example","title":"StructuredExpression example","text":"StructuredExpressions allow you to specify a predefined structure for an expression that exists outside of the regular AbstractExpressionNode objects which store expressions as trees.","category":"page"},{"location":"examples/structured_expression/","page":"StructuredExpression example","title":"StructuredExpression example","text":"Let's look at an example:","category":"page"},{"location":"examples/structured_expression/","page":"StructuredExpression example","title":"StructuredExpression example","text":"using DynamicExpressions, Random","category":"page"},{"location":"examples/structured_expression/","page":"StructuredExpression example","title":"StructuredExpression example","text":"First, we will create some normal Expression objects.","category":"page"},{"location":"examples/structured_expression/","page":"StructuredExpression example","title":"StructuredExpression example","text":"operators = OperatorEnum(; unary_operators=(cos, exp), binary_operators=(+, -, *, /))\nvariable_names = [\"x\", \"y\"]\nx = Expression(Node{Float64}(; feature=1); operators, variable_names)\ny = Expression(Node{Float64}(; feature=2); operators, variable_names)\n\ntypeof(x)","category":"page"},{"location":"examples/structured_expression/","page":"StructuredExpression example","title":"StructuredExpression example","text":"Any AbstractExpression, such as this Expression object, can be composed together using standard Julia math operations. For example, let's some complex expressions from these:","category":"page"},{"location":"examples/structured_expression/","page":"StructuredExpression example","title":"StructuredExpression example","text":"f = x * x - cos(2.5f0 * y + -0.5f0)\ng = exp(2.0 - y * y)\n\nf, g","category":"page"},{"location":"examples/structured_expression/","page":"StructuredExpression example","title":"StructuredExpression example","text":"We can then create a StructuredExpression from these two expressions. This is a composite AbstractExpression object that composes multiple expressions during evaluation.","category":"page"},{"location":"examples/structured_expression/","page":"StructuredExpression example","title":"StructuredExpression example","text":"ex = StructuredExpression(\n    (; f, g); structure=nt -> nt.f + nt.g, operators, variable_names\n)\nex","category":"page"},{"location":"examples/structured_expression/","page":"StructuredExpression example","title":"StructuredExpression example","text":"Note that this is displayed as a single tree, with the + operator used to combine them. Despite this, the expression is not actually stored with the + operator in an AbstractExpressionNode.","category":"page"},{"location":"examples/structured_expression/","page":"StructuredExpression example","title":"StructuredExpression example","text":"By default, using get_tree will evaluate the result of nt.f + nt.g. This let's us use things like the regular operations available to AbstractExpressionNodes:","category":"page"},{"location":"examples/structured_expression/","page":"StructuredExpression example","title":"StructuredExpression example","text":"length(get_tree(ex))","category":"page"},{"location":"examples/structured_expression/","page":"StructuredExpression example","title":"StructuredExpression example","text":"Next, let's try to evaluate this on some random data:","category":"page"},{"location":"examples/structured_expression/","page":"StructuredExpression example","title":"StructuredExpression example","text":"rng = Random.MersenneTwister(0)\nX = randn(rng, Float64, 2, 5)\nX","category":"page"},{"location":"examples/structured_expression/","page":"StructuredExpression example","title":"StructuredExpression example","text":"Followed by the evaluation. Since we have stored the operators directly in the expression object, we do not need to pass the operators explicitly. Evaluation of an AbstractExpression is set up to forward through get_tree, so this will work automatically.","category":"page"},{"location":"examples/structured_expression/","page":"StructuredExpression example","title":"StructuredExpression example","text":"ex(X)","category":"page"},{"location":"examples/structured_expression/","page":"StructuredExpression example","title":"StructuredExpression example","text":"Which we can verify against the individual expressions:","category":"page"},{"location":"examples/structured_expression/","page":"StructuredExpression example","title":"StructuredExpression example","text":"f(X) + g(X)","category":"page"},{"location":"examples/structured_expression/","page":"StructuredExpression example","title":"StructuredExpression example","text":"","category":"page"},{"location":"examples/structured_expression/","page":"StructuredExpression example","title":"StructuredExpression example","text":"This page was generated using Literate.jl.","category":"page"},{"location":"examples/expression/","page":"Expression example","title":"Expression example","text":"EditURL = \"../../../test/test_expressions.jl\"","category":"page"},{"location":"examples/expression/#Expression-example","page":"Expression example","title":"Expression example","text":"","category":"section"},{"location":"examples/expression/","page":"Expression example","title":"Expression example","text":"Expression is a fundamental type in DynamicExpressions that represents a mathematical expression as a tree structure. It combines an AbstractExpressionNode (typically a Node) with metadata like operators and variable names.","category":"page"},{"location":"examples/expression/","page":"Expression example","title":"Expression example","text":"using DynamicExpressions, Random","category":"page"},{"location":"examples/expression/","page":"Expression example","title":"Expression example","text":"First, let's define our operators and variable names:","category":"page"},{"location":"examples/expression/","page":"Expression example","title":"Expression example","text":"operators = OperatorEnum(;\n    binary_operators=(+, -, *, /), unary_operators=(sin, cos, exp)\n)","category":"page"},{"location":"examples/expression/","page":"Expression example","title":"Expression example","text":"variable_names = [\"x\", \"y\"]","category":"page"},{"location":"examples/expression/","page":"Expression example","title":"Expression example","text":"Now, let's create an Expression manually:","category":"page"},{"location":"examples/expression/","page":"Expression example","title":"Expression example","text":"x = Node{Float64}(; feature=1)\nx_expr = Expression(x; operators, variable_names)","category":"page"},{"location":"examples/expression/","page":"Expression example","title":"Expression example","text":"We can build up more complex expressions using these basic building blocks:","category":"page"},{"location":"examples/expression/","page":"Expression example","title":"Expression example","text":"y = Node{Float64}(; feature=2)\nc = Node{Float64}(; val=2.0)\ncomplex_node = Node(; op=3, l=x, r=Node(; op=1, l=y, r=c))","category":"page"},{"location":"examples/expression/","page":"Expression example","title":"Expression example","text":"where the 3 indicates * and 1 indicates +.","category":"page"},{"location":"examples/expression/","page":"Expression example","title":"Expression example","text":"complex_expr = Expression(complex_node; operators, variable_names)","category":"page"},{"location":"examples/expression/","page":"Expression example","title":"Expression example","text":"This expression includes its own metadata: the operators and variable names, and so there are no scope issues as with raw AbstractExpressionNode types which depend on the last-used metadata for convenience functions like printing. In other words, you can print this expression, or evaluate it, directly:","category":"page"},{"location":"examples/expression/","page":"Expression example","title":"Expression example","text":"rng = Random.MersenneTwister(0)\ncomplex_expr(randn(rng, 2, 5))","category":"page"},{"location":"examples/expression/","page":"Expression example","title":"Expression example","text":"While creating expressions manually is faster, and should be preferred within packages, it can be cumbersome for quickly writing more complex expressions. DynamicExpressions provides a more convenient way to create expressions using the parse_expression function, which directly parses a Julia object:","category":"page"},{"location":"examples/expression/","page":"Expression example","title":"Expression example","text":"parsed_expr = parse_expression(\n    :(sin(2.0 * x + exp(y + 5.0))); operators=operators, variable_names=variable_names\n)","category":"page"},{"location":"examples/expression/","page":"Expression example","title":"Expression example","text":"We can convert an expression into the primitive AbstractExpressionNode type with get_tree:","category":"page"},{"location":"examples/expression/","page":"Expression example","title":"Expression example","text":"tree = get_tree(parsed_expr)","category":"page"},{"location":"examples/expression/","page":"Expression example","title":"Expression example","text":"Some AbstractExpression types may choose to store their expression in a different way than simply saving it as one of the fields. For any expression, you can get the raw contents with get_contents:","category":"page"},{"location":"examples/expression/","page":"Expression example","title":"Expression example","text":"get_contents(parsed_expr)","category":"page"},{"location":"examples/expression/","page":"Expression example","title":"Expression example","text":"Similarly, you can get the metadata for an expression with get_metadata:","category":"page"},{"location":"examples/expression/","page":"Expression example","title":"Expression example","text":"get_metadata(parsed_expr)","category":"page"},{"location":"examples/expression/","page":"Expression example","title":"Expression example","text":"These can be used with with_contents and with_metadata to create new expressions based on the original:","category":"page"},{"location":"examples/expression/","page":"Expression example","title":"Expression example","text":"with_contents(parsed_expr, Node(; op=2, l=get_contents(parsed_expr)))","category":"page"},{"location":"examples/expression/","page":"Expression example","title":"Expression example","text":"Expression objects support various operations defined on regular trees, which permits us to overload specific methods with modified behavior. For example, we can count the number of nodes, which simply forwards to the method as it is defined on Node:","category":"page"},{"location":"examples/expression/","page":"Expression example","title":"Expression example","text":"node_count = count_nodes(parsed_expr)\nprintln(\"Number of nodes: $node_count\")","category":"page"},{"location":"examples/expression/","page":"Expression example","title":"Expression example","text":"The [tree_mapreduce] will by default call get_tree to get the tree, so it can be used with any expression type that overloads this method. For example, we can compute the depth of a tree:","category":"page"},{"location":"examples/expression/","page":"Expression example","title":"Expression example","text":"tree_mapreduce(\n    leaf -> 1, branch -> 1, (parent, child...) -> parent + max(child...), parsed_expr\n)","category":"page"},{"location":"examples/expression/","page":"Expression example","title":"Expression example","text":"We can also perform more complex operations, like simplification:","category":"page"},{"location":"examples/expression/","page":"Expression example","title":"Expression example","text":"complex_expr = parse_expression(\n    :((2.0 + x) + 3.0); operators=operators, variable_names=[\"x\"]\n)\nsimplified_expr = combine_operators(copy(complex_expr))\nprintln(\"Original: \", complex_expr)\nprintln(\"Simplified: \", simplified_expr)","category":"page"},{"location":"examples/expression/","page":"Expression example","title":"Expression example","text":"AbstractExpression types also have many operators in Base defined, which will automatically look up the matching index in the stored OperatorEnum. This means we can combine expressions like so:","category":"page"},{"location":"examples/expression/","page":"Expression example","title":"Expression example","text":"xs = [Expression(Node{Float64}(; feature=i); operators, variable_names) for i in 1:5]\n\nxs[1] + xs[2]","category":"page"},{"location":"examples/expression/","page":"Expression example","title":"Expression example","text":"These have the same type – they simply combine their AbstractExpressionNode objects and ensure the metadata is the same.","category":"page"},{"location":"examples/expression/","page":"Expression example","title":"Expression example","text":"typeof(xs[1] + xs[2])","category":"page"},{"location":"examples/expression/","page":"Expression example","title":"Expression example","text":"This gives us an easy way to quickly construct expressions with minimal memory overhead, and fast evaluation speed:","category":"page"},{"location":"examples/expression/","page":"Expression example","title":"Expression example","text":"ex = xs[1] * 2.1 - exp(3 * xs[2])","category":"page"},{"location":"examples/expression/","page":"Expression example","title":"Expression example","text":"Evaluation:","category":"page"},{"location":"examples/expression/","page":"Expression example","title":"Expression example","text":"X = randn(rng, 5, 2)\nex(X)","category":"page"},{"location":"examples/expression/","page":"Expression example","title":"Expression example","text":"Or, if we have loaded Zygote, we can differentiate with respect to the variables:","category":"page"},{"location":"examples/expression/","page":"Expression example","title":"Expression example","text":"using Zygote\nex'(X)","category":"page"},{"location":"examples/expression/","page":"Expression example","title":"Expression example","text":"Or the constants of the expression:","category":"page"},{"location":"examples/expression/","page":"Expression example","title":"Expression example","text":"ex'(X; variable=Val(false))","category":"page"},{"location":"examples/expression/","page":"Expression example","title":"Expression example","text":"Which can be used for optimization.","category":"page"},{"location":"examples/expression/","page":"Expression example","title":"Expression example","text":"","category":"page"},{"location":"examples/expression/","page":"Expression example","title":"Expression example","text":"This page was generated using Literate.jl.","category":"page"},{"location":"#Introduction","page":"Home","title":"Introduction","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"<img src=\"https://user-images.githubusercontent.com/7593028/196523542-305f3fc2-18d2-41e5-9252-1f96c3d0b7e7.png\" height=\"50%\" width=\"50%\">","category":"page"},{"location":"","page":"Home","title":"Home","text":"Ridiculously fast dynamic expressions.","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Image: ) (Image: CI) (Image: Coverage Status) (Image: Aqua QA) (Image: DispatchDoctor)","category":"page"},{"location":"","page":"Home","title":"Home","text":"DynamicExpressions.jl is the backbone of SymbolicRegression.jl and PySR.","category":"page"},{"location":"#Summary","page":"Home","title":"Summary","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"A dynamic expression is a snippet of code that can change throughout runtime - compilation is not possible! DynamicExpressions.jl does the following:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Defines an enum over user-specified operators.\nUsing this enum, it defines a very lightweight and type-stable data structure for arbitrary expressions.\nIt then generates specialized evaluation kernels for the space of potential operators.\nIt also generates kernels for the first-order derivatives, using Zygote.jl.\nDynamicExpressions.jl can also operate on arbitrary other types (vectors, tensors, symbols, strings, or even unions) - see last part below.\nIt also has import and export functionality with SymbolicUtils.jl.","category":"page"},{"location":"#Example","page":"Home","title":"Example","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"using DynamicExpressions\n\noperators = OperatorEnum(; binary_operators=[+, -, *], unary_operators=[cos])\nvariable_names = [\"x1\", \"x2\"]\n\nx1 = Expression(Node{Float64}(feature=1); operators, variable_names)\nx2 = Expression(Node{Float64}(feature=2); operators, variable_names)\n\nexpression = x1 * cos(x2 - 3.2)\n\nX = randn(Float64, 2, 100);\nexpression(X) # 100-element Vector{Float64}","category":"page"},{"location":"#Speed","page":"Home","title":"Speed","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"First, what happens if we naively use Julia symbols to define and then evaluate this expression?","category":"page"},{"location":"","page":"Home","title":"Home","text":"@btime eval(:(X[1, :] .* cos.(X[2, :] .- 3.2)))\n# 117,000 ns","category":"page"},{"location":"","page":"Home","title":"Home","text":"This is quite slow, meaning it will be hard to quickly search over the space of expressions. Let's see how DynamicExpressions.jl compares:","category":"page"},{"location":"","page":"Home","title":"Home","text":"@btime expression(X)\n# 607 ns","category":"page"},{"location":"","page":"Home","title":"Home","text":"Much faster! And we didn't even need to compile it. (Internally, this is calling eval_tree_array(expression, X)). ","category":"page"},{"location":"","page":"Home","title":"Home","text":"If we change expression dynamically with a random number generator, it will have the same performance:","category":"page"},{"location":"","page":"Home","title":"Home","text":"@btime ex(X) setup=(ex = copy(expression); ex.tree.op = rand(1:3) #= random operator in [+, -, *] =#)\n# 640 ns","category":"page"},{"location":"","page":"Home","title":"Home","text":"Now, let's see the performance if we had hard-coded these expressions:","category":"page"},{"location":"","page":"Home","title":"Home","text":"f(X) = X[1, :] .* cos.(X[2, :] .- 3.2)\n@btime f(X)\n# 629 ns","category":"page"},{"location":"","page":"Home","title":"Home","text":"So, our dynamic expression evaluation is about the same (or even a bit faster) as evaluating a basic hard-coded expression! Let's see if we can optimize the speed of the hard-coded version:","category":"page"},{"location":"","page":"Home","title":"Home","text":"f_optimized(X) = begin\n    y = Vector{Float64}(undef, 100)\n    @inbounds @simd for i=1:100\n        y[i] = X[1, i] * cos(X[2, i] - 3.2)\n    end\n    y\nend\n@btime f_optimized(X)\n# 526 ns","category":"page"},{"location":"","page":"Home","title":"Home","text":"The DynamicExpressions.jl version is only 25% slower than one which has been optimized by hand into a single SIMD kernel! Not bad at all.","category":"page"},{"location":"","page":"Home","title":"Home","text":"More importantly: we can change expression throughout runtime, and expect the same performance. This makes this data structure ideal for symbolic regression and other evaluation-based searches over expression trees.","category":"page"},{"location":"#Derivatives","page":"Home","title":"Derivatives","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"We can also compute gradients with the same speed:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Zygote  # trigger extension\n\noperators = OperatorEnum(; binary_operators=[+, -, *], unary_operators=[cos])\nvariable_names = [\"x1\", \"x2\"]\nx1, x2 = (Expression(Node{Float64}(feature=i); operators, variable_names) for i in 1:2)\n\nexpression = x1 * cos(x2 - 3.2)","category":"page"},{"location":"","page":"Home","title":"Home","text":"We can take the gradient with respect to inputs with simply the ' character:","category":"page"},{"location":"","page":"Home","title":"Home","text":"grad = expression'(X)","category":"page"},{"location":"","page":"Home","title":"Home","text":"This is quite fast:","category":"page"},{"location":"","page":"Home","title":"Home","text":"@btime expression'(X)\n# 2333 ns","category":"page"},{"location":"","page":"Home","title":"Home","text":"and again, we can change this expression at runtime, without loss in performance!","category":"page"},{"location":"","page":"Home","title":"Home","text":"@btime ex'(X) setup=(ex = copy(expression); ex.tree.op = rand(1:3))\n# 2333 ns","category":"page"},{"location":"","page":"Home","title":"Home","text":"Internally, this is calling the eval_grad_tree_array function, which performs forward-mode automatic differentiation on the expression tree with Zygote-compiled kernels. We can also compute the derivative with respect to constants:","category":"page"},{"location":"","page":"Home","title":"Home","text":"result, grad, did_finish = eval_grad_tree_array(expression, X; variable=false)","category":"page"},{"location":"#Generic-types","page":"Home","title":"Generic types","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Does this work for only scalar operators on real numbers, or will it work for MyCrazyType?","category":"page"},{"location":"","page":"Home","title":"Home","text":"I'm so glad you asked. DynamicExpressions.jl actually will work for arbitrary types! However, to work on operators other than real scalars, you need to use the GenericOperatorEnum <: AbstractOperatorEnum instead of the normal OperatorEnum. Let's try it with strings!","category":"page"},{"location":"","page":"Home","title":"Home","text":"_x1 = Node{String}(; feature=1) ","category":"page"},{"location":"","page":"Home","title":"Home","text":"This node, will be used to index input data (whatever it may be) with either data[feature] (1D abstract arrays) or selectdim(data, 1, feature) (ND abstract arrays). Let's now define some operators to use:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using DynamicExpressions: @declare_expression_operator\n\nmy_string_func(x::String) = \"ello $x\"\n@declare_expression_operator(my_string_func, 1)\n\noperators = GenericOperatorEnum(; binary_operators=[*], unary_operators=[my_string_func])\n\nx1 = Expression(_x1; operators, variable_names)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Now, let's create an expression:","category":"page"},{"location":"","page":"Home","title":"Home","text":"expression = \"H\" * my_string_func(x1)\n# ^ `(H * my_string_func(x1))`\n\nexpression([\"World!\", \"Me?\"])\n# Hello World!","category":"page"},{"location":"","page":"Home","title":"Home","text":"So indeed it works for arbitrary types. It is a bit slower due to the potential for type instability, but it's not too bad:","category":"page"},{"location":"","page":"Home","title":"Home","text":"@btime expression([\"Hello\", \"Me?\"])\n# 103.105 ns (4 allocations: 144 bytes)","category":"page"},{"location":"#Tensors","page":"Home","title":"Tensors","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Does this work for tensors, or even unions of scalars and tensors?","category":"page"},{"location":"","page":"Home","title":"Home","text":"Also yes! Let's see:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using DynamicExpressions\nusing DynamicExpressions: @declare_expression_operator\n\nT = Union{Float64,Vector{Float64}}\n\n# Some operators on tensors (multiple dispatch can be used for different behavior!)\nvec_add(x, y) = x .+ y\nvec_square(x) = x .* x\n\n# Enable these operators for DynamicExpressions.jl:\n@declare_expression_operator(vec_add, 2)\n@declare_expression_operator(vec_square, 1)\n\n# Set up an operator enum:\noperators = GenericOperatorEnum(;binary_operators=[vec_add], unary_operators=[vec_square])\n\n# Construct the expression:\nvariable_names = [\"x1\"]\nc1 = Expression(Node{T}(; val=0.0); operators, variable_names)  # Scalar constant\nc2 = Expression(Node{T}(; val=[1.0, 2.0, 3.0]); operators, variable_names)  # Vector constant\nx1 = Expression(Node{T}(; feature=1); operators, variable_names)\n\nexpression = vec_add(vec_add(vec_square(x1), c2), c1)\n\nX = [[-1.0, 5.2, 0.1], [0.0, 0.0, 0.0]]\n\n# Evaluate!\nexpression(X)  # [2.0, 29.04, 3.01]","category":"page"},{"location":"","page":"Home","title":"Home","text":"Note that if an operator is not defined for the particular input, nothing will be returned instead.","category":"page"},{"location":"","page":"Home","title":"Home","text":"This is all still pretty fast, too:","category":"page"},{"location":"","page":"Home","title":"Home","text":"@btime expression(X)\n# 461.086 ns (13 allocations: 448 bytes)\n@btime eval(:(vec_add(vec_add(vec_square(X[1]), [1.0, 2.0, 3.0]), 0.0)))\n# 115,000 ns","category":"page"},{"location":"#Contents","page":"Home","title":"Contents","text":"","category":"section"},{"location":"utils/#Node-utilities","page":"Utils","title":"Node utilities","text":"","category":"section"},{"location":"utils/#Base","page":"Utils","title":"Base","text":"","category":"section"},{"location":"utils/","page":"Utils","title":"Utils","text":"Various functions in Base are overloaded to treat an AbstractNode as a collection of its nodes.","category":"page"},{"location":"utils/","page":"Utils","title":"Utils","text":"copy(tree::AbstractExpressionNode; break_sharing::Val=Val(false))\nfilter(f::Function, tree::AbstractNode; break_sharing::Val=Val(false))\ncount(f::Function, tree::AbstractNode; init=0, break_sharing::Val=Val(false))\nforeach(f::Function, tree::AbstractNode; break_sharing::Val=Val(false))\nsum(f::F, tree::AbstractNode; init=0, return_type=Undefined, f_on_shared=_default_shared_aggregation, break_sharing::Val=Val(false)) where {F<:Function}\nmapreduce(f::F, op::G, tree::AbstractNode; return_type, f_on_shared, break_sharing) where {F<:Function,G<:Function}\nany(f::F, tree::AbstractNode) where {F<:Function}\nall(f::F, tree::AbstractNode) where {F<:Function}\nmap(f::F, tree::AbstractNode, result_type::Type{RT}=Nothing; break_sharing::Val=Val(false)) where {F<:Function,RT}\nconvert(::Type{<:AbstractExpressionNode{T1}}, n::AbstractExpressionNode{T2}) where {T1,T2}\nhash(tree::AbstractExpressionNode{T}, h::UInt; break_sharing::Val=Val(false)) where {T}","category":"page"},{"location":"utils/#Base.copy-Tuple{AbstractExpressionNode}","page":"Utils","title":"Base.copy","text":"copy(tree::AbstractExpressionNode; break_sharing::Val=Val(false))\n\nCopy a node, recursively copying all children nodes. This is more efficient than the built-in copy.\n\nIf break_sharing is set to Val(true), sharing in a tree will be ignored.\n\n\n\n\n\n","category":"method"},{"location":"utils/#Base.filter-Tuple{Function, AbstractNode}","page":"Utils","title":"Base.filter","text":"filter(f::Function, tree::AbstractNode; break_sharing::Val=Val(false))\n\nFilter nodes of a tree, returning a flat array of the nodes for which the function returns true.\n\n\n\n\n\n","category":"method"},{"location":"utils/#Base.count-Tuple{Function, AbstractNode}","page":"Utils","title":"Base.count","text":"count(f::F, tree::AbstractNode; init=0, break_sharing::Val{BS}=Val(false)) where {F<:Function,BS}\n\nCount the number of nodes in a tree for which the function returns true.\n\n\n\n\n\n","category":"method"},{"location":"utils/#Base.foreach-Tuple{Function, AbstractNode}","page":"Utils","title":"Base.foreach","text":"foreach(f, c...) -> Nothing\n\nCall function f on each element of iterable c. For multiple iterable arguments, f is called elementwise, and iteration stops when any iterator is finished.\n\nforeach should be used instead of map when the results of f are not needed, for example in foreach(println, array).\n\nExamples\n\njulia> tri = 1:3:7; res = Int[];\n\njulia> foreach(x -> push!(res, x^2), tri)\n\njulia> res\n3-element Vector{Int64}:\n  1\n 16\n 49\n\njulia> foreach((x, y) -> println(x, \" with \", y), tri, 'a':'z')\n1 with a\n4 with b\n7 with c\n\n\n\n\n\nforeach(f::Function, tree::AbstractNode; break_sharing::Val=Val(false))\n\nApply a function to each node in a tree without returning the results.\n\n\n\n\n\n","category":"method"},{"location":"utils/#Base.sum-Union{Tuple{F}, Tuple{F, AbstractNode}} where F<:Function","page":"Utils","title":"Base.sum","text":"sum(f::Function, tree::AbstractNode; result_type=Undefined, f_on_shared=_default_shared_aggregation, break_sharing::Val{BS}=Val(false)) where {F<:Function,BS}\n\nSum the results of a function over a tree. For graphs with shared nodes such as GraphNode, the function f_on_shared is called on the result of each shared node. This is used to avoid double-counting shared nodes (default behavior).\n\n\n\n\n\n","category":"method"},{"location":"utils/#Base.mapreduce-Union{Tuple{G}, Tuple{F}, Tuple{F, G, AbstractNode}} where {F<:Function, G<:Function}","page":"Utils","title":"Base.mapreduce","text":"mapreduce(f::Function, op::Function, tree::AbstractNode; result_type, f_on_shared, break_sharing)\n\nMap a function over a tree and aggregate the result using an operator op.\n\n\n\n\n\n","category":"method"},{"location":"utils/#Base.any-Union{Tuple{F}, Tuple{F, AbstractNode}} where F<:Function","page":"Utils","title":"Base.any","text":"any(f::Function, tree::AbstractNode)\n\nReduce a flag function over a tree, returning true if the function returns true for any node. By using this instead of tree_mapreduce, we can take advantage of early exits.\n\n\n\n\n\n","category":"method"},{"location":"utils/#Base.all-Union{Tuple{F}, Tuple{F, AbstractNode}} where F<:Function","page":"Utils","title":"Base.all","text":"all(f::Function, tree::AbstractNode)\n\nReduce a flag function over a tree, returning true if the function returns true for all nodes, false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"utils/#Base.map-Union{Tuple{RT}, Tuple{F}, Tuple{F, AbstractNode}, Tuple{F, AbstractNode, Type{RT}}} where {F<:Function, RT}","page":"Utils","title":"Base.map","text":"map(f::F, tree::AbstractNode, result_type::Type{RT}=Nothing; break_sharing::Val{BS}=Val(false)) where {F<:Function,RT,BS}\n\nMap a function over a tree and return a flat array of the results in depth-first order. Pre-specifying the result_type of the function can be used to avoid extra allocations.\n\n\n\n\n\n","category":"method"},{"location":"utils/#Base.convert-Union{Tuple{T2}, Tuple{T1}, Tuple{Type{<:AbstractExpressionNode{T1}}, AbstractExpressionNode{T2}}} where {T1, T2}","page":"Utils","title":"Base.convert","text":"convert(::Type{<:AbstractExpressionNode{T1}}, n::AbstractExpressionNode{T2}) where {T1,T2}\n\nConvert a AbstractExpressionNode{T2} to a AbstractExpressionNode{T1}. This will recursively convert all children nodes to AbstractExpressionNode{T1}, using convert(T1, tree.val) at constant nodes.\n\nArguments\n\n::Type{AbstractExpressionNode{T1}}: Type to convert to.\ntree::AbstractExpressionNode{T2}: AbstractExpressionNode to convert.\n\n\n\n\n\n","category":"method"},{"location":"utils/#Base.hash-Union{Tuple{T}, Tuple{AbstractExpressionNode{T}, UInt64}} where T","page":"Utils","title":"Base.hash","text":"hash(tree::AbstractExpressionNode{T}[, h::UInt]; break_sharing::Val=Val(false)) where {T}\n\nCompute a hash of a tree. This will compute a hash differently if nodes are shared in a tree. This is ignored if break_sharing is set to Val(true).\n\n\n\n\n\n","category":"method"},{"location":"utils/#Printing","page":"Utils","title":"Printing","text":"","category":"section"},{"location":"utils/","page":"Utils","title":"Utils","text":"Trees are printed using the string_tree function, which is very configurable:","category":"page"},{"location":"utils/","page":"Utils","title":"Utils","text":"string_tree(tree::Node, operators::AbstractOperatorEnum)","category":"page"},{"location":"utils/#DynamicExpressions.StringsModule.string_tree-Tuple{Node, AbstractOperatorEnum}","page":"Utils","title":"DynamicExpressions.StringsModule.string_tree","text":"string_tree(\n    tree::AbstractExpressionNode{T},\n    operators::Union{AbstractOperatorEnum,Nothing}=nothing;\n    f_variable::F1=string_variable,\n    f_constant::F2=string_constant,\n    variable_names::Union{Array{String,1},Nothing}=nothing,\n    # Deprecated\n    varMap=nothing,\n)::String where {T,F1<:Function,F2<:Function}\n\nConvert an equation to a string.\n\nArguments\n\ntree: the tree to convert to a string\noperators: the operators used to define the tree\n\nKeyword Arguments\n\nf_variable: (optional) function to convert a variable to a string, with arguments (feature::UInt8, variable_names).\nf_constant: (optional) function to convert a constant to a string, with arguments (val,)\nvariable_names::Union{Array{String, 1}, Nothing}=nothing: (optional) what variables to print for each feature.\n\n\n\n\n\n","category":"method"},{"location":"utils/","page":"Utils","title":"Utils","text":"The standard show and print methods will use the most recently-created OperatorEnum in a string_tree.","category":"page"},{"location":"utils/#Sampling","page":"Utils","title":"Sampling","text":"","category":"section"},{"location":"utils/","page":"Utils","title":"Utils","text":"There are also methods for random sampling of nodes:","category":"page"},{"location":"utils/","page":"Utils","title":"Utils","text":"NodeSampler\nrand(rng::AbstractRNG, tree::AbstractNode)\nrand(rng::AbstractRNG, sampler::NodeSampler{N,F,Nothing}) where {N,F}","category":"page"},{"location":"utils/#DynamicExpressions.RandomModule.NodeSampler","page":"Utils","title":"DynamicExpressions.RandomModule.NodeSampler","text":"NodeSampler(; tree, filter::Function=Returns(true), weighting::Union{Nothing,Function}=nothing, break_sharing::Val=Val(false))\n\nDefines a sampler of nodes in a tree.\n\nArguments\n\ntree: The tree to sample nodes from. For a regular Node, nodes are sampled uniformly. For a GraphNode, nodes are also sampled uniformly (e.g., in sin(x) + {x}, the x has equal probability of being sampled from the sin or the + node, because it is shared), unless break_sharing is set to Val(true).\nfilter::Function: A function that takes a node and returns a boolean indicating whether the node should be sampled. Defaults to Returns(true).\nweighting::Union{Nothing,Function}: A function that takes a node and returns a weight for the node, if it passes the filter, proportional to the probability of sampling the node. If nothing, all nodes are sampled uniformly.\nbreak_sharing::Val: If Val(true), the sampler will break sharing in the tree, and sample nodes uniformly from the tree.\n\n\n\n\n\n","category":"type"},{"location":"utils/#Base.rand-Tuple{AbstractRNG, AbstractNode}","page":"Utils","title":"Base.rand","text":"rand(rng::AbstractRNG, tree::AbstractNode)\n\nSample a node from a tree according to the default sampler NodeSampler(; tree).\n\n\n\n\n\n","category":"method"},{"location":"utils/#Base.rand-Union{Tuple{F}, Tuple{N}, Tuple{AbstractRNG, NodeSampler{N, F, Nothing}}} where {N, F}","page":"Utils","title":"Base.rand","text":"rand(rng::AbstractRNG, sampler::NodeSampler)\n\nSample a node from a tree according to the sampler sampler.\n\n\n\n\n\n","category":"method"},{"location":"utils/#Internal-utilities","page":"Utils","title":"Internal utilities","text":"","category":"section"},{"location":"utils/","page":"Utils","title":"Utils","text":"Almost all node utilities are crafted using the tree_mapreduce function, which evaluates a mapreduce over a tree-like (or graph-like) structure:","category":"page"},{"location":"utils/","page":"Utils","title":"Utils","text":"tree_mapreduce","category":"page"},{"location":"utils/#DynamicExpressions.NodeModule.tree_mapreduce","page":"Utils","title":"DynamicExpressions.NodeModule.tree_mapreduce","text":"tree_mapreduce(\n    f::Function,\n    [f_branch::Function,]\n    op::Function,\n    tree::AbstractNode,\n    [result_type::Type=Undefined];\n    f_on_shared::Function=(result, is_shared) -> result,\n    break_sharing::Val=Val(false),\n)\n\nMap a function over a tree and aggregate the result using an operator op. op should be defined with inputs (parent, child...) -> so that it can aggregate both unary and binary operators. op will not be called for leafs of the tree. This differs from a normal mapreduce in that it allows different treatment for parent nodes than children nodes. If this is not necessary, you may use the regular mapreduce instead. The argument break_sharing can be used to break connections in a GraphNode.\n\nYou can also provide separate functions for leaf (variable/constant) nodes and branch (operator) nodes.\n\nExamples\n\njulia> operators = OperatorEnum(; binary_operators=[+, *]);\n\njulia> tree = Node(; feature=1) + Node(; feature=2) * 3.2;\n\njulia> tree_mapreduce(t -> 1, +, tree)  # count nodes. (regular mapreduce also works)\n5\n\njulia> tree_mapreduce(t -> 1, (p, c...) -> p + max(c...), tree)  # compute depth. regular mapreduce would fail!\n5\n\njulia> tree_mapreduce(vcat, tree) do t\n    t.degree == 2 ? [t.op] : UInt8[]\nend  # Get list of binary operators used. (regular mapreduce also works)\n2-element Vector{UInt8}:\n 1\n 2\n\njulia> tree_mapreduce(vcat, tree) do t\n    (t.degree == 0 && t.constant) ? [t.val] : Float64[]\nend  # Get list of constants. (regular mapreduce also works)\n1-element Vector{Float64}:\n 3.2\n\n\n\n\n\n","category":"function"},{"location":"utils/","page":"Utils","title":"Utils","text":"Various other utility functions include the following:","category":"page"},{"location":"utils/","page":"Utils","title":"Utils","text":"filter_map\nfilter_map!","category":"page"},{"location":"utils/#DynamicExpressions.NodeModule.filter_map","page":"Utils","title":"DynamicExpressions.NodeModule.filter_map","text":"filter_map(filter_fnc::Function, map_fnc::Function, tree::AbstractNode, result_type::Type, break_sharing::Val=Val(false))\n\nA faster equivalent to map(map_fnc, filter(filter_fnc, tree)) that avoids the intermediate allocation. However, using this requires specifying the result_type of map_fnc so the resultant array can be preallocated.\n\n\n\n\n\n","category":"function"},{"location":"utils/#DynamicExpressions.NodeModule.filter_map!","page":"Utils","title":"DynamicExpressions.NodeModule.filter_map!","text":"filter_map!(filter_fnc::Function, map_fnc::Function, stack::Vector{GT}, tree::AbstractNode)\n\nEquivalent to filter_map, but stores the results in a preallocated array.\n\n\n\n\n\n","category":"function"}]
}
