var documenterSearchIndex = {"docs":
[{"location":"api/#API","page":"API","title":"API","text":"","category":"section"},{"location":"api/#Operator-Enum","page":"API","title":"Operator Enum","text":"All equations are represented as a tree of operators. Each node in this tree specifies its operator with an integer - which indexes an enum of operators. This enum is defined as follows:\n\nThis is just for scalar operators. However, you can use the following for more general operators:\n\nBy default, these operators will define helper functions for constructing trees, so that you can write Node(;feature=1) + Node(;feature=2) instead of Node(1, Node(;feature=1), Node(;feature=2)) (assuming + is the first operator). You can turn this off with define_helper_functions=false.\n\nFor other operators not found in Base, including user-defined functions, you may use the @extend_operators macro:\n\nThis will extend the operators you have passed to work with Node types, so that it is easier to construct expression trees.\n\nNote that you are free to use the Node constructors directly. This is a more robust approach, and should be used when creating libraries which use DynamicExpressions.jl.","category":"section"},{"location":"api/#Nodes","page":"API","title":"Nodes","text":"Equations are specified as binary trees with the Node type, defined as follows:\n\nWhen you create an Options object, the operators passed are also re-defined for Node types. This allows you use, e.g., t=Node(; feature=1) * 3f0 to create a tree, so long as * was specified as a binary operator.\n\nWhen using these node constructors, types will automatically be promoted. You can convert the type of a node using convert:\n\nYou can set a tree (in-place) with set_node!:\n\nYou can create a copy of a node with copy_node:","category":"section"},{"location":"api/#Generic-Node-Accessors","page":"API","title":"Generic Node Accessors","text":"For working with nodes of arbitrary arity:\n\nExamples:\n\n# Define operators including ternary\nmy_ternary(x, y, z) = x + y * z\noperators = OperatorEnum(((sin,), (+, *), (my_ternary,)))  # (unary, binary, ternary)\n\ntree = Node{Float64,3}(; op=1, children=(Node{Float64,3}(; val=1.0), Node{Float64,3}(; val=2.0)))\nnew_child = Node{Float64,3}(; val=3.0)\n\nleft_child = get_child(tree, 1)\nright_child = get_child(tree, 2)\n\nset_child!(tree, new_child, 1)\n\nleft, right = get_children(tree, Val(2))  # type stable\n\n# Transform to ternary operation\nchild1, child2, child3 = Node{Float64,3}(; val=4.0), Node{Float64,3}(; val=5.0), Node{Float64,3}(; val=6.0)\nset_children!(tree, (child1, child2, child3))\ntree.op = 1  # my_ternary\ntree.degree = 3","category":"section"},{"location":"api/#Graph-Nodes","page":"API","title":"Graph Nodes","text":"You can describe an equation as a graph rather than a tree by using the GraphNode type:\n\nThis makes it so you can have multiple parents for a given node, and share parts of an expression. For example:\n\njulia> operators = OperatorEnum(1 => (cos, sin, exp), 2 => (+, -, *));\n\njulia> x1, x2 = GraphNode(feature=1), GraphNode(feature=2)\n(x1, x2)\n\njulia> y = sin(x1) + 1.5\nsin(x1) + 1.5\n\njulia> z = exp(y) + y\nexp(sin(x1) + 1.5) + {(sin(x1) + 1.5)}\n\nHere, the curly braces {} indicate that the node is shared by another (or more) parent node.\n\nThis means that we only need to change it once to have changes propagate across the expression:\n\njulia> get_child(y, 2).val *= 0.9\n1.35\n\njulia> z\nexp(sin(x1) + 1.35) + {(sin(x1) + 1.35)}\n\nThis also means there are fewer nodes to describe an expression:\n\njulia> length(z)\n6\n\njulia> length(convert(Node, z))\n10\n\nwhere we have converted the GraphNode to a Node type, which breaks shared connections into separate nodes.","category":"section"},{"location":"api/#Abstract-Types","page":"API","title":"Abstract Types","text":"Both the Node and GraphNode types are subtypes of the abstract type:\n\nwhich can be used to create additional expression-like types. The supertype of this abstract type is the AbstractNode type, which is more generic but does not have all of the same methods:","category":"section"},{"location":"api/#Expressions","page":"API","title":"Expressions","text":"A higher-level user-facing type is the Expression:\n\nThis is a subtype of AbstractExpression.\n\nwhich can be used for defining custom types, such as the ParametricExpression:\n\nAnother example is the StructuredExpression type, for defining rigid predefined operations in an expression tree:\n\nYou may use operators directly on AbstractExpression objects to create a new object containing the combined expression tree, so long as those objects have identical operators in their metadata.\n\nYou can extract and set contents and metadata with a few utility functions, including:\n\nTo declare a new operator for expressions, you may use:","category":"section"},{"location":"api/#Interfaces","page":"API","title":"Interfaces","text":"The interfaces for AbstractExpression and AbstractExpressionNode are tested using Interfaces.jl. You can see the interfaces with:\n\nYou can declare a new type as implementing these with, e.g.,\n\nusing DynamicExpressions: ExpressionInterface, all_ei_methods_except\nusing Interface: @implements, Arguments, Interface\n\n# Add all optional methods:\nvalid_optional_methods = all_ei_methods_except(())\n\n@implements ExpressionInterface{valid_optional_methods} MyCustomExpression [Arguments()]\n\nYou can then test the interface is implemented correctly using, for example,\n\n@test Interface.test(ExpressionInterface, MyCustomExpression, [ex::MyCustomExpression])\n\nNote that this may not flag all potential issues, so be sure to still read the details about what methods can be implemented and customized.","category":"section"},{"location":"api/#DynamicExpressions.OperatorEnumModule.OperatorEnum","page":"API","title":"DynamicExpressions.OperatorEnumModule.OperatorEnum","text":"OperatorEnum(ops::Tuple{Vararg{Tuple}})\n\nFields\n\nops: A tuple of tuples of operators. Index i corresponds to operators with i arguments.\n\n\n\n\n\n","category":"type"},{"location":"api/#DynamicExpressions.OperatorEnumModule.GenericOperatorEnum","page":"API","title":"DynamicExpressions.OperatorEnumModule.GenericOperatorEnum","text":"GenericOperatorEnum(ops::Tuple{Vararg{Tuple}})\n\nDefines an enum over operators for non-scalar data types (vectors, matrices, strings, custom types).\n\nFields\n\nops: A tuple of operators, with index i corresponding to the operator tuple for a node of degree i.\n\n\n\n\n\n","category":"type"},{"location":"api/#DynamicExpressions.OperatorEnumConstructionModule.@extend_operators-Tuple{Any}","page":"API","title":"DynamicExpressions.OperatorEnumConstructionModule.@extend_operators","text":"@extend_operators operators [kws...]\n\nExtends all operators defined in this operator enum to work on the Node type. While by default this is already done for operators defined in Base when you create an enum and pass define_helper_functions=true, this does not apply to the user-defined operators. Thus, to do so, you must apply this macro to the operator enum in the same module you have the operators defined.\n\n\n\n\n\n","category":"macro"},{"location":"api/#DynamicExpressions.NodeModule.Node","page":"API","title":"DynamicExpressions.NodeModule.Node","text":"Node{T,D} <: AbstractExpressionNode{T,D}\n\nNode defines a symbolic expression stored in a binary tree. A single Node instance is one \"node\" of this tree, and has references to its children. By tracing through the children nodes, you can evaluate or print a given expression.\n\nFields\n\ndegree::UInt8: Degree of the node. 0 for constants, 1 for   unary operators, 2 for binary operators, etc. Maximum of D.\nconstant::Bool: Whether the node is a constant.\nval::T: Value of the node. If degree==0, and constant==true,   this is the value of the constant. It has a type specified by the   overall type of the Node (e.g., Float64).\nfeature::UInt16: Index of the feature to use in the   case of a feature node. Only defined if degree == 0 && constant == false.\nop::UInt8: If degree==1, this is the index of the operator   in operators.unaops. If degree==2, this is the index of the   operator in operators.binops. In other words, this is an enum   of the operators, and is dependent on the specific OperatorEnum   object. Only defined if degree >= 1\nchildren::NTuple{D,Node{T,D}}: Children of the node. Only defined up to degree\n\nFor accessing and modifying children, use get_child, set_child!, get_children, and set_children!.\n\nConstructors\n\nNode([T]; val=nothing, feature=nothing, op=nothing, children=nothing, allocator=default_allocator)\nNode{T}(; val=nothing, feature=nothing, op=nothing, children=nothing, allocator=default_allocator)\n\nCreate a new node in an expression tree. If T is not specified in either the type or the first argument, it will be inferred from the value of val passed or the children. The children keyword is used to pass in a collection of children nodes.\n\nYou may also construct nodes via the convenience operators generated by creating an OperatorEnum.\n\nYou may also choose to specify a default memory allocator for the node other than simply Node{T}() in the allocator keyword argument.\n\n\n\n\n\n","category":"type"},{"location":"api/#Base.convert-Union{Tuple{N2}, Tuple{N1}, Tuple{D2}, Tuple{D1}, Tuple{T2}, Tuple{T1}, Tuple{Type{N1}, N2}} where {T1, T2, D1, D2, N1<:AbstractExpressionNode{T1, D1}, N2<:AbstractExpressionNode{T2, D2}}","page":"API","title":"Base.convert","text":"convert(::Type{<:AbstractExpressionNode{T1}}, n::AbstractExpressionNode{T2}) where {T1,T2}\n\nConvert a AbstractExpressionNode{T2} to a AbstractExpressionNode{T1}. This will recursively convert all children nodes to AbstractExpressionNode{T1}, using convert(T1, tree.val) at constant nodes.\n\nArguments\n\n::Type{AbstractExpressionNode{T1}}: Type to convert to.\ntree::AbstractExpressionNode{T2}: AbstractExpressionNode to convert.\n\n\n\n\n\n","category":"method"},{"location":"api/#DynamicExpressions.NodeModule.set_node!","page":"API","title":"DynamicExpressions.NodeModule.set_node!","text":"set_node!(tree::AbstractExpressionNode{T}, new_tree::AbstractExpressionNode{T}) where {T}\n\nSet every field of tree equal to the corresponding field of new_tree.\n\n\n\n\n\n","category":"function"},{"location":"api/#DynamicExpressions.NodeModule.copy_node","page":"API","title":"DynamicExpressions.NodeModule.copy_node","text":"copy_node(tree::AbstractExpressionNode; break_sharing::Val{BS}=Val(false)) where {BS}\n\nCopy a node, recursively copying all children nodes. This is more efficient than the built-in copy.\n\nIf break_sharing is set to Val(true), sharing in a tree will be ignored.\n\n\n\n\n\n","category":"function"},{"location":"api/#DynamicExpressions.NodeModule.get_child","page":"API","title":"DynamicExpressions.NodeModule.get_child","text":"get_child(node::AbstractNode, i::Integer)\n\nReturn the i-th child of a node (1-indexed).\n\n\n\n\n\n","category":"function"},{"location":"api/#DynamicExpressions.NodeModule.set_child!","page":"API","title":"DynamicExpressions.NodeModule.set_child!","text":"set_child!(node::AbstractNode, child::AbstractNode, i::Integer)\n\nReplace the i-th child of a node (1-indexed) with the given child node. Returns the new child. Updates the children tuple in-place.\n\n\n\n\n\n","category":"function"},{"location":"api/#DynamicExpressions.NodeModule.get_children","page":"API","title":"DynamicExpressions.NodeModule.get_children","text":"get_children(node::AbstractNode, n::Integer)\nget_children(node::AbstractNode, ::Val{n})\n\nReturn a tuple of exactly n children of the node. You should use the .degree field of a node to determine the number of children to return. Typically this is done within a Base.Cartesian.@nif statement for total type stability.\n\n\n\n\n\n","category":"function"},{"location":"api/#DynamicExpressions.NodeModule.set_children!","page":"API","title":"DynamicExpressions.NodeModule.set_children!","text":"set_children!(node::AbstractNode, children::Tuple)\n\nReplace all children of a node with the given tuple. If fewer children are provided than the node's maximum degree, remaining slots are filled with poison nodes.\n\n\n\n\n\n","category":"function"},{"location":"api/#DynamicExpressions.NodeModule.GraphNode","page":"API","title":"DynamicExpressions.NodeModule.GraphNode","text":"GraphNode{T,D} <: AbstractExpressionNode{T,D}\n\nExactly the same as Node{T,D}, but with the assumption that some nodes will be shared. All copies of this graph-like structure will be performed with this assumption, to preserve structure of the graph.\n\nExamples\n\njulia> operators = OperatorEnum(1 => (cos, sin), 2 => (+, -, *));\n\njulia> x = GraphNode(feature=1)\nx1\n\njulia> y = sin(x) + x\nsin(x1) + {x1}\n\njulia> cos(y) * y\ncos(sin(x1) + {x1}) * {(sin(x1) + {x1})}\n\nNote how the {} indicates a node is shared, and this is the same node as seen earlier in the string.\n\nThis has the same constructors as Node{T}. Shared nodes are created simply by using the same node in multiple places when constructing or setting properties.\n\n\n\n\n\n","category":"type"},{"location":"api/#DynamicExpressions.NodeModule.AbstractExpressionNode","page":"API","title":"DynamicExpressions.NodeModule.AbstractExpressionNode","text":"AbstractExpressionNode{T,D} <: AbstractNode{D}\n\nAbstract type for nodes that represent an expression. Along with the fields required for AbstractNode, this additionally must have fields for:\n\nconstant::Bool: Whether the node is a constant.\nval::T: Value of the node. If degree==0, and constant==true,   this is the value of the constant. It has a type specified by the   overall type of the Node (e.g., Float64).\nfeature::UInt16: Index of the feature to use in the   case of a feature node. Only used if degree==0 and constant==false.    Only defined if degree == 0 && constant == false.\nop::UInt8: If degree==1, this is the index of the operator   in operators.unaops. If degree==2, this is the index of the   operator in operators.binops. In other words, this is an enum   of the operators, and is dependent on the specific OperatorEnum   object. Only defined if degree >= 1\n\nInterface\n\nSee NodeInterface for a full description of the interface implementation, as well as tests to verify correctness.\n\nYou must define CustomNode{_T,_D}() where {_T,_D} = new{_T,_D}() for each custom node type, as well as constructorof and with_type_parameters.\n\nIn addition, you may choose to define the following functions, to override the defaults behavior, in particular if you wish to add additional fields to your type.\n\nleaf_copy and branch_copy\nleaf_convert and branch_convert\nleaf_equal and branch_equal\nleaf_hash and branch_hash\npreserve_sharing\n\n\n\n\n\n","category":"type"},{"location":"api/#DynamicExpressions.NodeModule.AbstractNode","page":"API","title":"DynamicExpressions.NodeModule.AbstractNode","text":"AbstractNode{D}\n\nAbstract type for trees which can have up to D children per node. Must have the following fields:\n\ndegree::UInt8: Degree of the node. This should be a value   between 0 and D, inclusive.\nchildren: A collection of up to D children nodes. The number   of children which are active is given by the degree field,   but for type stability reasons, you can have inactive children.\n\nDeprecated fields\n\nl::AbstractNode{D}: Left child of the current node. Should only be   defined if degree >= 1; otherwise, leave it undefined (see the   the constructors of Node{T} for an example).   Don't use nothing to represent an undefined value   as it will incur a large performance penalty.\nr::AbstractNode{D}: Right child of the current node. Should only   be defined if degree >= 2.\n\n\n\n\n\n","category":"type"},{"location":"api/#DynamicExpressions.ExpressionModule.Expression","page":"API","title":"DynamicExpressions.ExpressionModule.Expression","text":"Expression{T, N, D} <: AbstractExpression{T, N}\n\n(Experimental) Defines a high-level, user-facing, expression type that encapsulates an expression tree (like Node) along with associated metadata for evaluation and rendering.\n\nFields\n\ntree::N: The root node of the raw expression tree.\nmetadata::Metadata{D}: A named tuple of settings for the expression,   such as the operators and variable names.\n\nConstructors\n\nExpression(tree::AbstractExpressionNode, metadata::NamedTuple): Construct from the fields\n@parse_expression(expr, operators=operators, variable_names=variable_names, node_type=Node): Parse a Julia expression with a given context and create an Expression object.\n\nUsage\n\nThis type is intended for end-users to interact with and manipulate expressions at a high level, abstracting away the complexities of the underlying expression tree operations.\n\n\n\n\n\n","category":"type"},{"location":"api/#DynamicExpressions.ExpressionModule.AbstractExpression","page":"API","title":"DynamicExpressions.ExpressionModule.AbstractExpression","text":"AbstractExpression{T,N}\n\n(Experimental) Abstract type for user-facing expression types, which contain both the raw expression tree operating on a value type of T, as well as associated metadata to evaluate and render the expression.\n\nSee ExpressionInterface for a full description of the interface implementation, as well as tests to verify correctness.\n\nIf you wish to use @parse_expression, you can also customize the parsing behavior with\n\nparse_leaf\n\n\n\n\n\n","category":"type"},{"location":"api/#DynamicExpressions.ParametricExpressionModule.ParametricExpression","page":"API","title":"DynamicExpressions.ParametricExpressionModule.ParametricExpression","text":"ParametricExpression{T,N<:ParametricNode{T},D<:NamedTuple} <: AbstractExpression{T,N}\n\n(Experimental) An expression to store parameters for a tree\n\n\n\n\n\n","category":"type"},{"location":"api/#DynamicExpressions.ParametricExpressionModule.ParametricNode","page":"API","title":"DynamicExpressions.ParametricExpressionModule.ParametricNode","text":"A type of expression node that also stores a parameter index\n\n\n\n\n\n","category":"type"},{"location":"api/#DynamicExpressions.StructuredExpressionModule.StructuredExpression","page":"API","title":"DynamicExpressions.StructuredExpressionModule.StructuredExpression","text":"StructuredExpression{T,F,N,E,TS,D} <: AbstractStructuredExpression{T,F,N,E,D} <: AbstractExpression{T,N}\n\nThis expression type allows you to combine multiple expressions together in a predefined way.\n\nParameters\n\nT: The numeric value type of the expressions.\nF: The type of the structure function, which combines each expression into a single expression.\nN: The type of the nodes inside expressions.\nE: The type of the expressions.\nTS: The type of the named tuple containing those inner expressions.\nD: The type of the metadata, another named tuple.\n\nUsage\n\nFor example, we can create two expressions, f, and g, and then combine them together in a new expression, f_plus_g, using a constructor function that simply adds them together:\n\nkws = (;\n    binary_operators=[+, -, *, /],\n    unary_operators=[-, cos, exp],\n    variable_names=[\"x\", \"y\"],\n)\nf = parse_expression(:(x * x - cos(2.5f0 * y + -0.5f0)); kws...)\ng = parse_expression(:(exp(-(y * y))); kws...)\n\nf_plus_g = StructuredExpression((; f, g); structure=nt -> nt.f + nt.g)\n\nNow, when evaluating f_plus_g, this expression type will return the result of adding together the results of f and g.\n\nYou can dispatch on a particular structured expression with the second type parameter, F, which is the function defined above:\n\nmy_factory(nt) = nt.f + nt.g\n\nBase.show(io::IO, e::StructuredExpression{T,typeof(my_factory)}) where {T} = ...\n\nwhich will create a new method particular to this expression type defined on that function.\n\n\n\n\n\n","category":"type"},{"location":"api/#DynamicExpressions.ExpressionModule.get_contents","page":"API","title":"DynamicExpressions.ExpressionModule.get_contents","text":"get_contents(ex::AbstractExpression)\n\nGet the contents of the expression, which might be a plain AbstractExpressionNode, or some combination of them, or other data. This should include everything other than that returned by get_metadata.\n\n\n\n\n\n","category":"function"},{"location":"api/#DynamicExpressions.ExpressionModule.with_contents","page":"API","title":"DynamicExpressions.ExpressionModule.with_contents","text":"with_contents(ex::AbstractExpression, tree::AbstractExpressionNode)\nwith_contents(ex::AbstractExpression, tree::AbstractExpression)\n\nCreate a new expression based on ex but with a different tree\n\n\n\n\n\n","category":"function"},{"location":"api/#DynamicExpressions.ExpressionModule.get_metadata","page":"API","title":"DynamicExpressions.ExpressionModule.get_metadata","text":"get_metadata(ex::AbstractExpression)\n\nGet the metadata of the expression, which might be a plain NamedTuple, or some combination of them, or other data. This should include everything other than that returned by get_contents.\n\n\n\n\n\n","category":"function"},{"location":"api/#DynamicExpressions.ExpressionModule.with_metadata","page":"API","title":"DynamicExpressions.ExpressionModule.with_metadata","text":"with_metadata(ex::AbstractExpression, metadata)\nwith_metadata(ex::AbstractExpression; metadata...)\n\nCreate a new expression based on ex but with a different metadata.\n\n\n\n\n\n","category":"function"},{"location":"api/#DynamicExpressions.ExpressionModule.get_tree","page":"API","title":"DynamicExpressions.ExpressionModule.get_tree","text":"get_tree(ex::AbstractExpression)\n\nA method that extracts the expression tree from AbstractExpression and should return an AbstractExpressionNode.\n\n\n\n\n\n","category":"function"},{"location":"api/#DynamicExpressions.ExpressionAlgebraModule.@declare_expression_operator","page":"API","title":"DynamicExpressions.ExpressionAlgebraModule.@declare_expression_operator","text":"@declare_expression_operator(op, arity)\n\nDeclare an operator function for AbstractExpression types.\n\nThis macro generates methods for the given operator op that work with AbstractExpression arguments.  The arity parameter specifies the number of arguments the operator takes.\n\n\n\n\n\n","category":"macro"},{"location":"api/#DynamicExpressions.InterfacesModule.ExpressionInterface","page":"API","title":"DynamicExpressions.InterfacesModule.ExpressionInterface","text":"    ExpressionInterface\n\nAn Interfaces.jl Interface with mandatory components (:get_contents, :get_metadata, :get_tree, :get_operators, :get_variable_names, :copy, :with_contents, :with_metadata) and optional components (:copy_into!, :count_nodes, :count_constant_nodes, :count_depth, :index_constant_nodes, :has_operators, :has_constants, :get_scalar_constants, :set_scalar_constants!, :string_tree, :default_node_type, :constructorof, :tree_mapreduce).\n\nDefines the interface of AbstractExpression for user-facing expression types, which can store operators, extra parameters, functional forms, variable names, etc.\n\nExtended help\n\nMandatory keys:\n\nget_contents: extracts the runtime contents of an expression\nget_metadata: extracts the runtime metadata of an expression\nget_tree: extracts the expression tree from AbstractExpression\nget_operators: returns the operators used in the expression (or pass operators explicitly to override)\nget_variable_names: returns the variable names used in the expression (or pass variable_names explicitly to override)\ncopy: returns a copy of the expression\nwith_contents: returns the expression with different tree\nwith_metadata: returns the expression with different metadata\n\nOptional keys:\n\ncopy_into!: copies an expression into a preallocated container\ncount_nodes: counts the number of nodes in the expression tree\ncount_constant_nodes: counts the number of constant nodes in the expression tree\ncount_depth: calculates the depth of the expression tree\nindex_constant_nodes: indexes constants in the expression tree\nhas_operators: checks if the expression has operators\nhas_constants: checks if the expression has constants\nget_scalar_constants: gets constants from the expression tree, returning a tuple of: (1) a flat vector of the constants, and (2) an reference object that can be used by set_scalar_constants! to efficiently set them back\nset_scalar_constants!: sets constants in the expression tree, given: (1) a flat vector of constants, (2) the expression, and (3) the reference object produced by get_scalar_constants\nstring_tree: returns a string representation of the expression tree\ndefault_node_type: returns the default node type for the expression\nconstructorof: gets the constructor function for a type\ntree_mapreduce: applies a function across the tree\n\n\n\n\n\n","category":"type"},{"location":"api/#DynamicExpressions.InterfacesModule.NodeInterface","page":"API","title":"DynamicExpressions.InterfacesModule.NodeInterface","text":"    NodeInterface\n\nAn Interfaces.jl Interface with mandatory components (:create_node, :get_children, :copy, :hash, :any, :equality, :preserve_sharing, :constructorof, :eltype, :with_type_parameters, :with_max_degree, :default_allocator, :set_node!, :count_nodes, :tree_mapreduce) and optional components (:copy_into!, :leaf_copy, :leaf_copy_into!, :leaf_convert, :leaf_hash, :leaf_equal, :branch_copy, :branch_copy_into!, :branch_convert, :branch_hash, :branch_equal, :count_depth, :is_node_constant, :count_constant_nodes, :filter_map, :has_constants, :get_scalar_constants, :set_scalar_constants!, :index_constant_nodes, :has_operators).\n\nDefines the interface for AbstractExpressionNode which can include various operations such as copying, hashing, and checking equality, as well as tree-specific operations like map-reduce and node manipulation.\n\nExtended help\n\nMandatory keys:\n\ncreate_node: creates a new instance of the node type\nget_children: returns the children of the node\ncopy: returns a copy of the tree\nhash: returns the hash of the tree\nany: checks if any element of the tree satisfies a condition\nequality: checks equality of the tree with itself and its copy\npreserve_sharing: checks if the node type preserves sharing\nconstructorof: gets the constructor function for a node type\neltype: gets the element type of the node\nwith_type_parameters: applies type parameters to the node type\nwith_max_degree: changes the maximum degree of a node type\ndefault_allocator: gets the default allocator for the node type\nset_node!: sets the node's value\ncount_nodes: counts the number of nodes in the tree\ntree_mapreduce: applies a function across the tree\n\nOptional keys:\n\ncopy_into!: copies a node into a preallocated container\nleaf_copy: copies a leaf node\nleaf_copy_into!: copies a leaf node in-place\nleaf_convert: converts a leaf node\nleaf_hash: computes the hash of a leaf node\nleaf_equal: checks equality of two leaf nodes\nbranch_copy: copies a branch node\nbranch_copy_into!: copies a branch node in-place\nbranch_convert: converts a branch node\nbranch_hash: computes the hash of a branch node\nbranch_equal: checks equality of two branch nodes\ncount_depth: calculates the depth of the tree\nis_node_constant: checks if the node is a constant\ncount_constant_nodes: counts the number of constant nodes\nfilter_map: applies a filter and map function to the tree\nhas_constants: checks if the tree has constants\nget_scalar_constants: gets constants from the tree, returning a tuple of: (1) a flat vector of the constants, and (2) a reference object that can be used by set_scalar_constants! to efficiently set them back\nset_scalar_constants!: sets constants in the tree, given: (1) a flat vector of constants, (2) the tree, and (3) the reference object produced by get_scalar_constants\nindex_constant_nodes: indexes constants in the tree\nhas_operators: checks if the tree has operators\n\n\n\n\n\n","category":"type"},{"location":"eval/#Evaluation-and-Derivatives","page":"Eval","title":"Evaluation & Derivatives","text":"","category":"section"},{"location":"eval/#Evaluation","page":"Eval","title":"Evaluation","text":"Given an expression tree specified with a Node type, you may evaluate the expression over an array of data with the following command:\n\nYou can also use the following shorthand by using the expression as a function:\n\n    (tree::AbstractExpressionNode)(X, operators::OperatorEnum; kws...)\n\nEvaluate a binary tree (equation) over a given input data matrix. The\noperators contain all of the operators used. This function fuses doublets\nand triplets of operations for lower memory usage.\n\n# Arguments\n- `tree::AbstractExpressionNode`: The root node of the tree to evaluate.\n- `cX::AbstractMatrix{T}`: The input data to evaluate the tree on.\n- `operators::OperatorEnum`: The operators used in the tree.\n- `kws...`: Passed to [`eval_tree_array`](@ref).\n\n# Returns\n- `output::AbstractVector{T}`: the result, which is a 1D array.\n    Any NaN, Inf, or other failure during the evaluation will result in the entire\n    output array being set to NaN.\n\nFor example,\n\nusing DynamicExpressions\n\noperators = OperatorEnum(1 => (cos, sin), 2 => (+, -, *, /))\ntree = Node(; feature=1) * cos(Node(; feature=2) - 3.2)\n\ntree([1 2 3; 4 5 6.], operators)\n\nThis is possible because when you call OperatorEnum, it automatically re-defines (::Node)(X) to call the evaluation operation with the given operators loaded. It also re-defines print, show, and the various operators, to work with the Node type.\n\nwarning: Warning\nThe Node type does not know about which OperatorEnum you used to create it. Thus, if you define an expression with one OperatorEnum, and then try to evaluate it or print it with a different OperatorEnum, you will get undefined behavior!For safer behavior, you should use Expression objects.\n\nEvaluation options are specified using EvalOptions:\n\nYou can also work with arbitrary types, by defining a GenericOperatorEnum instead. The notation is the same for eval_tree_array, though it will return nothing when it can't find a method, and not do any NaN checks:\n\nLikewise for the shorthand notation:\n\n    (tree::Node)(X::AbstractMatrix, operators::GenericOperatorEnum; throw_errors::Bool=true)\n\n# Arguments\n- `X::AbstractArray`: The input data to evaluate the tree on.\n- `operators::GenericOperatorEnum`: The operators used in the tree.\n- `throw_errors::Bool=true`: Whether to throw errors\n    if they occur during evaluation. Otherwise,\n    MethodErrors will be caught before they happen and\n    evaluation will return `nothing`,\n    rather than throwing an error. This is useful in cases\n    where you are unsure if a particular tree is valid or not,\n    and would prefer to work with `nothing` as an output.\n\n# Returns\n- `output`: the result of the evaluation.\n    If evaluation failed, `nothing` will be returned for the first argument.\n    A `false` complete means an operator was called on input types\n    that it was not defined for. You can change this behavior by\n    setting `throw_errors=false`.","category":"section"},{"location":"eval/#Derivatives","page":"Eval","title":"Derivatives","text":"DynamicExpressions.jl can efficiently compute first-order derivatives of expressions with respect to variables or constants. This is done using either eval_diff_tree_array, to compute derivative with respect to a single variable, or with eval_grad_tree_array, to compute the gradient with respect all variables (or, all constants). Both use forward-mode automatic, but use Zygote.jl to compute derivatives of each operator, so this is very efficient.\n\nYou can compute gradients this with shorthand notation as well (which by default computes gradients with respect to input matrix, rather than constants).\n\n    (tree::Node{T})'(X::AbstractMatrix{T}, operators::OperatorEnum; turbo::Bool=false, variable::Bool=true)\n\nCompute the forward-mode derivative of an expression, using a similar\nstructure and optimization to eval_tree_array. `variable` specifies whether\nwe should take derivatives with respect to features (i.e., X), or with respect\nto every constant in the expression.\n\n# Arguments\n- `X::AbstractMatrix{T}`: The data matrix, with each column being a data point.\n- `operators::OperatorEnum`: The operators used to create the `tree`.\n- `variable::Bool`: Whether to take derivatives with respect to features (i.e., `X` - with `variable=true`),\n    or with respect to every constant in the expression (`variable=false`).\n- `turbo::Bool`: Use `LoopVectorization.@turbo` for faster evaluation.\n\n# Returns\n\n- `(evaluation, gradient, complete)::Tuple{AbstractVector{T}, AbstractMatrix{T}, Bool}`: the normal evaluation,\n    the gradient, and whether the evaluation completed as normal (or encountered a nan or inf).\n\nAlternatively, you can compute higher-order derivatives by using ForwardDiff on the function differentiable_eval_tree_array, although this will be slower.","category":"section"},{"location":"eval/#Enzyme","page":"Eval","title":"Enzyme","text":"DynamicExpressions.jl also supports automatic differentiation with Enzyme.jl. Note that this is extremely experimental. You should expect to see occasional incorrect gradients. Be sure to explicitly verify gradients are correct for a particular space of operators (e.g., with finite differences).\n\nLet's look at an example. First, let's create a tree:\n\nusing DynamicExpressions\n\noperators = OperatorEnum(1 => (cos, sin), 2 => (+, -, *, /))\n\nx1 = Node{Float64}(feature=1)\nx2 = Node{Float64}(feature=2)\n\ntree = 0.5 * x1 + cos(x2 - 0.2)\n\nNow, say we want to take the derivative of this expression with respect to x1 and x2. First, let's evaluate it normally:\n\nX = [1.0 2.0 3.0; 4.0 5.0 6.0]  # 2x3 matrix (2 features, 3 rows)\n\ntree(X, operators)\n\nNow, let's use Enzyme.jl to compute the derivative of the outputs with respect to x1 and x2, using reverse-mode autodiff:\n\nusing Enzyme\n\nfunction my_loss_function(tree, X, operators)\n    # Get the outputs\n    y = tree(X, operators)\n    # Sum them (so we can take a gradient, rather than a jacobian)\n    return sum(y)\nend\n\n\ndX = begin\n    storage=zero(X)\n    autodiff(\n        Reverse,\n        my_loss_function,\n        Active,\n        ## Actual arguments to function:\n        Const(tree),\n        Duplicated(X, storage),\n        Const(operators),\n    )\n    storage\nend\n\nThis will get returned as\n\n 2×3 Matrix{Float64}:\n  0.5       0.5       0.5\n  0.611858  0.996165  0.464602\n\nwhich one can confirm is the correct gradient!\n\nThis will take a while the first time you run it, as Enzyme needs to take the gradients of the actual LLVM IR code. Subsequent runs won't spend any time compiling and be much faster.\n\nSome general notes about this:\n\nWe want to take a reverse-mode gradient, so we pass Reverse to autodiff.\nSince we want to take the gradient of the output of my_loss_function, we declare Active as the third argument.\nFollowing this, we pass our actual arguments to the function.\nObjects which we don't want to take gradients with respect to,  and also don't temporarily store any data during the computation  (such as tree and operators here) should be wrapped with Const.\nObjects which we wish to take derivatives with respect to, we need to use   Duplicated, and explicitly create a copy of it, with all numerical values   set to zero. Enzyme will then store the derivatives in this object.\n\nNote that you should never use anything other than turbo=Val(false) with Enzyme, as Enzyme and LoopVectorization are not compatible, and will cause a segfault. Even using turbo=false will not work, because it would cause Enzyme to trace the (unused) LoopVectorization code!","category":"section"},{"location":"eval/#DynamicExpressions.EvaluateModule.eval_tree_array-Union{Tuple{T}, Tuple{AbstractExpressionNode{T}, AbstractMatrix{T}, OperatorEnum}} where T","page":"Eval","title":"DynamicExpressions.EvaluateModule.eval_tree_array","text":"eval_tree_array(\n    tree::AbstractExpressionNode{T},\n    cX::AbstractMatrix{T},\n    operators::OperatorEnum;\n    eval_options::Union{EvalOptions,Nothing}=nothing,\n) where {T}\n\nEvaluate a binary tree (equation) over a given input data matrix. The operators contain all of the operators used. This function fuses doublets and triplets of operations for lower memory usage.\n\nArguments\n\ntree::AbstractExpressionNode: The root node of the tree to evaluate.\ncX::AbstractMatrix{T}: The input data to evaluate the tree on, with shape [num_features, num_rows].\noperators::OperatorEnum: The operators used in the tree.\neval_options::Union{EvalOptions,Nothing}: See EvalOptions for documentation   on the different evaluation modes.\n\nReturns\n\n(output, complete)::Tuple{AbstractVector{T}, Bool}: the result,   which is a 1D array, as well as if the evaluation completed   successfully (true/false). A false complete means an infinity   or nan was encountered, and a large loss should be assigned   to the equation.\n\nNotes\n\nThis function can be represented by the following pseudocode:\n\ndef eval(current_node)\n    if current_node is leaf\n        return current_node.value\n    elif current_node is degree 1\n        return current_node.operator(eval(current_node.left_child))\n    else\n        return current_node.operator(eval(current_node.left_child), eval(current_node.right_child))\n\nThe bulk of the code is for optimizations and pre-emptive NaN/Inf checks, which speed up evaluation significantly.\n\n\n\n\n\n","category":"method"},{"location":"eval/#DynamicExpressions.EvaluateModule.EvalOptions","page":"Eval","title":"DynamicExpressions.EvaluateModule.EvalOptions","text":"EvalOptions\n\nThis holds options for expression evaluation, such as evaluation backend.\n\nFields\n\nturbo::Val{T}=Val(false): If Val{true}, use LoopVectorization.jl for faster   evaluation.\nbumper::Val{B}=Val(false): If Val{true}, use Bumper.jl for faster evaluation.\nearly_exit::Val{E}=Val(true): If Val{true}, any element of any step becoming   NaN or Inf will terminate the computation. For eval_tree_array, this will   result in the second return value, the completion flag, being false. For    calling an expression using tree(X), this will result in NaNs filling   the entire buffer. This early exit is performed to avoid wasting compute cycles.   Setting Val{false} will continue the computation as usual and thus result in   NaNs only in the elements that actually have NaNs.\nbuffer::Union{ArrayBuffer,Nothing}: If not nothing, use this buffer for evaluation.   This should be an instance of ArrayBuffer which has an array field and an   index field used to iterate which buffer slot to use.\nuse_fused::Val{U}=Val(true): If Val{true}, use fused kernels for faster   evaluation. Setting this to Val{false} will skip the fused kernels, meaning that   you would only need to overload deg0_eval, deg1_eval and deg2_eval for custom   evaluation.\n\n\n\n\n\n","category":"type"},{"location":"eval/#DynamicExpressions.EvaluateModule.eval_tree_array-Tuple{Node, AbstractMatrix, GenericOperatorEnum}","page":"Eval","title":"DynamicExpressions.EvaluateModule.eval_tree_array","text":"eval_tree_array(tree::AbstractExpressionNode, cX::AbstractMatrix, operators::GenericOperatorEnum; throw_errors::Bool=true)\n\nEvaluate a generic binary tree (equation) over a given input data, whatever that input data may be. The operators enum contains all of the operators used. Unlike eval_tree_array with the normal OperatorEnum, the array cX is sliced only along the first dimension. i.e., if cX is a vector, then the output of a feature node will be a scalar. If cX is a 3D tensor, then the output of a feature node will be a 2D tensor. Note also that tree.feature will index along the first axis of cX.\n\nHowever, there is no requirement about input and output types in general. You may set up your tree such that some operator nodes work on tensors, while other operator nodes work on scalars. eval_tree_array will simply return nothing if a given operator is not defined for the given input type.\n\nThis function can be represented by the following pseudocode:\n\nfunction eval(current_node)\n    if current_node is leaf\n        return current_node.value\n    elif current_node is degree 1\n        return current_node.operator(eval(current_node.left_child))\n    else\n        return current_node.operator(eval(current_node.left_child), eval(current_node.right_child))\n\nArguments\n\ntree::AbstractExpressionNode: The root node of the tree to evaluate.\ncX::AbstractArray: The input data to evaluate the tree on.\noperators::GenericOperatorEnum: The operators used in the tree.\nthrow_errors::Bool=true: Whether to throw errors   if they occur during evaluation. Otherwise,   MethodErrors will be caught before they happen and    evaluation will return nothing,   rather than throwing an error. This is useful in cases   where you are unsure if a particular tree is valid or not,   and would prefer to work with nothing as an output.\n\nReturns\n\n(output, complete)::Tuple{Any, Bool}: the result,   as well as if the evaluation completed successfully (true/false).   If evaluation failed, nothing will be returned for the first argument.   A false complete means an operator was called on input types   that it was not defined for.\n\n\n\n\n\n","category":"method"},{"location":"eval/#DynamicExpressions.EvaluateDerivativeModule.eval_diff_tree_array-Union{Tuple{T}, Tuple{Node{T}, AbstractMatrix{T}, OperatorEnum, Integer}} where T<:Number","page":"Eval","title":"DynamicExpressions.EvaluateDerivativeModule.eval_diff_tree_array","text":"eval_diff_tree_array(\n    tree::AbstractExpressionNode{T},\n    cX::AbstractMatrix{T},\n    operators::OperatorEnum,\n    direction::Integer;\n    turbo::Union{Bool,Val}=Val(false)\n) where {T<:Number}\n\nCompute the forward derivative of an expression, using a similar structure and optimization to evaltreearray. direction is the index of a particular variable in the expression. e.g., direction=1 would indicate derivative with respect to x1.\n\nArguments\n\ntree::AbstractExpressionNode: The expression tree to evaluate.\ncX::AbstractMatrix{T}: The data matrix, with shape [num_features, num_rows].\noperators::OperatorEnum: The operators used to create the tree.\ndirection::Integer: The index of the variable to take the derivative with respect to.\nturbo::Union{Bool,Val}: Use LoopVectorization.jl for faster evaluation. Currently this does not have   any effect.\n\nReturns\n\n(evaluation, derivative, complete)::Tuple{AbstractVector{T}, AbstractVector{T}, Bool}: the normal evaluation,   the derivative, and whether the evaluation completed as normal (or encountered a nan or inf).\n\n\n\n\n\n","category":"method"},{"location":"eval/#DynamicExpressions.EvaluateDerivativeModule.eval_grad_tree_array-Union{Tuple{T}, Tuple{Node{T}, AbstractMatrix{T}, OperatorEnum}} where T<:Number","page":"Eval","title":"DynamicExpressions.EvaluateDerivativeModule.eval_grad_tree_array","text":"eval_grad_tree_array(tree::AbstractExpressionNode{T}, cX::AbstractMatrix{T}, operators::OperatorEnum; variable::Union{Bool,Val}=Val(false), turbo::Union{Bool,Val}=Val(false))\n\nCompute the forward-mode derivative of an expression, using a similar structure and optimization to evaltreearray. variable specifies whether we should take derivatives with respect to features (i.e., cX), or with respect to every constant in the expression.\n\nArguments\n\ntree::AbstractExpressionNode{T}: The expression tree to evaluate.\ncX::AbstractMatrix{T}: The data matrix, with each column being a data point.\noperators::OperatorEnum: The operators used to create the tree.\nvariable::Union{Bool,Val}: Whether to take derivatives with respect to features (i.e., cX - with variable=true),   or with respect to every constant in the expression (variable=false).\nturbo::Union{Bool,Val}: Use LoopVectorization.jl for faster evaluation. Currently this does not have   any effect.\n\nReturns\n\n(evaluation, gradient, complete)::Tuple{AbstractVector{T}, AbstractMatrix{T}, Bool}: the normal evaluation,   the gradient, and whether the evaluation completed as normal (or encountered a nan or inf).\n\n\n\n\n\n","category":"method"},{"location":"eval/#DynamicExpressions.EvaluateModule.differentiable_eval_tree_array-Union{Tuple{T}, Tuple{Node{T}, AbstractMatrix{T}, OperatorEnum}} where T<:Number","page":"Eval","title":"DynamicExpressions.EvaluateModule.differentiable_eval_tree_array","text":"differentiable_eval_tree_array(tree::AbstractExpressionNode, cX::AbstractMatrix, operators::OperatorEnum)\n\nEvaluate an expression tree in a way that can be auto-differentiated.\n\n\n\n\n\n","category":"method"},{"location":"examples/base_operations/#Node-and-Tree-Operations","page":"Node and Tree Operations","title":"Node and Tree Operations","text":"This example demonstrates how to create and manipulate expression trees using the Node type.\n\nFirst, let's create a node to reference feature=1 of our dataset:\n\nusing DynamicExpressions, Random, Test\n\nx = Node{Float64}(; feature=1)\n@test x isa Node{Float64,2}\n\nWe can also create values, using val:\n\nconst_1 = Node{Float64}(; val=1.0)\n\nNow, let's declare some operators to use in our expression tree.\n\nNote that the declaration of the OperatorEnum updates a global mapping from operators to their index in a list. This is purely for convenience, and most of the time, you would either operate directly on the OperatorEnum, like with eval_tree_array, or use Expression objects to store them alongside the expression.\n\noperators = OperatorEnum(1 => (sin, exp), 2 => (+, -, *, /))\n\nNow, let's create another variable\n\ny = Node{Float64}(; feature=2)\n\nAnd we can now create expression trees:\n\ntree = (x + y) * const_1 - sin(x)\n\nThe type of this is the same as the type of the variables and constants, meaning we have type stability:\n\ntypeof(tree), typeof(x)\n\nWe can also just use scalars directly:\n\ntree2 = 2x - sin(x)\n\nAs you have noticed, the tree is printed as an expression. We can control this with the string_tree function, which also lets us pass the operators explicitly:\n\nstring_tree(tree, operators; variable_names=[\"x\", \"y\"])\n\nThis also lets us control how each branch node and leaf node (variable/constant) is printed in the tree.\n\nThere are a lot of operations you can do on tree objects, such as evaluating them over batched data:\n\nrng = Random.MersenneTwister(0)\ntree2(randn(rng, Float64, 2, 5), operators)\n\nNow, how does this actually work? How do these functions traverse the tree?\n\nThe core operation is the tree_mapreduce function, which applies a function to each node in the tree, and then combines the results. Unlike a standard mapreduce, the tree_mapreduce allows you to specify different maps for branch nodes and leaf nodes. Also unlike a mapreduce, the reduction function needs to handle a variable number of inputs – it takes the mapped branch node, as well as all of the mapped children.\n\nLet's see an example. Say we just want to count the nodes in the tree:\n\nnum_nodes = tree_mapreduce(node -> 1, +, tree)\n\nHere, the + handles both the cases of 1 child and 2 children. Here, we didn't need to specify a custom branch function, but we could do that too:\n\nnum_leafs = tree_mapreduce(leaf_node -> 1, branch_node -> 0, +, tree)\n\nThis counts the number of leaf nodes in the tree. For tree, this was x, y, const_1, and x.\n\nYou can access fields of the Node type here to create more complex operations, just be careful to not access undefined fields (be sure to read the API specification).\n\nMost operators can be built with this simple pattern, even including evaluation of the tree, and printing of expressions. (It also allows for graph-like expressions like GraphNode via a f_on_shared keyword.)\n\nAs a more complex example, let's compute the depth of a tree. Here, we need to use a more complicated reduction operation – the max:\n\ndepth = tree_mapreduce(\n    node -> 1, (parent, children...) -> 1 + max(children...), x + sin(sin(exp(x)))\n)\n\nHere, the max handles both the cases of 1 child and 2 children. The parent node contributes 1 at each depth. Note that the inputs to the reduction are already mapped to 1.\n\nMany operations do not need to handle branching, and thus, many of the typical operations on collections in Julia are available. For example, we can collect each node in the tree into a list:\n\ncollect(tree)\n\nNote that the first node in this list is the root note, which is the subtraction operation:\n\ntree == first(collect(tree))\n\nWe can look at the operator:\n\ntree.degree, tree.op\n\nAnd compare it to our list:\n\noperators.binops\n\nMany other collection operations are available. For example, we can aggregate a relationship over each node:\n\nsum(node -> node.degree == 0 ? 1.5 : 0.0, tree)\n\nWe can even use any which has an early exit from the depth-first tree traversal:\n\nany(node -> node.degree == 2, tree)\n\nWe can also randomly sample nodes, using NodeSampler, which permits filters:\n\nrand(rng, NodeSampler(; tree, filter=node -> node.degree == 1))\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"examples/structured_expression/#StructuredExpression-example","page":"StructuredExpression example","title":"StructuredExpression example","text":"StructuredExpressions allow you to specify a predefined structure for an expression that exists outside of the regular AbstractExpressionNode objects which store expressions as trees.\n\nLet's look at an example:\n\nusing DynamicExpressions, Random\n\nFirst, we will create some normal Expression objects.\n\noperators = OperatorEnum(1 => (cos, exp), 2 => (+, -, *, /))\nvariable_names = [\"x\", \"y\"]\nx = Expression(Node{Float64}(; feature=1); operators, variable_names)\ny = Expression(Node{Float64}(; feature=2); operators, variable_names)\n\ntypeof(x)\n\nAny AbstractExpression, such as this Expression object, can be composed together using standard Julia math operations. For example, let's some complex expressions from these:\n\nf = x * x - cos(2.5f0 * y + -0.5f0)\ng = exp(2.0 - y * y)\n\nf, g\n\nWe can then create a StructuredExpression from these two expressions. This is a composite AbstractExpression object that composes multiple expressions during evaluation.\n\nex = StructuredExpression(\n    (; f, g); structure=nt -> nt.f + nt.g, operators, variable_names\n)\nex\n\nNote that this is displayed as a single tree, with the + operator used to combine them. Despite this, the expression is not actually stored with the + operator in an AbstractExpressionNode.\n\nBy default, using get_tree will evaluate the result of nt.f + nt.g. This let's us use things like the regular operations available to AbstractExpressionNodes:\n\nlength(get_tree(ex))\n\nNext, let's try to evaluate this on some random data:\n\nrng = Random.MersenneTwister(0)\nX = randn(rng, Float64, 2, 5)\nX\n\nFollowed by the evaluation. Since we have stored the operators directly in the expression object, we do not need to pass the operators explicitly. Evaluation of an AbstractExpression is set up to forward through get_tree, so this will work automatically.\n\nex(X)\n\nWhich we can verify against the individual expressions:\n\nf(X) + g(X)\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"examples/expression/#Expression-example","page":"Expression example","title":"Expression example","text":"Expression is a fundamental type in DynamicExpressions that represents a mathematical expression as a tree structure. It combines an AbstractExpressionNode (typically a Node) with metadata like operators and variable names.\n\nusing DynamicExpressions, Random\n\nFirst, let's define our operators and variable names:\n\noperators = OperatorEnum(1 => (sin, cos, exp), 2 => (+, -, *, /))\n\nvariable_names = [\"x\", \"y\"]\n\nNow, let's create an Expression manually:\n\nx = Node{Float64}(; feature=1)\nx_expr = Expression(x; operators, variable_names)\n\nWe can build up more complex expressions using these basic building blocks:\n\ny = Node{Float64}(; feature=2)\nc = Node{Float64}(; val=2.0)\ncomplex_node = Node(; op=3, l=x, r=Node(; op=1, l=y, r=c))\n\nwhere the 3 indicates * and 1 indicates +.\n\ncomplex_expr = Expression(complex_node; operators, variable_names)\n\nThis expression includes its own metadata: the operators and variable names, and so there are no scope issues as with raw AbstractExpressionNode types which depend on the last-used metadata for convenience functions like printing. In other words, you can print this expression, or evaluate it, directly:\n\nrng = Random.MersenneTwister(0)\ncomplex_expr(randn(rng, 2, 5))\n\nWhile creating expressions manually is faster, and should be preferred within packages, it can be cumbersome for quickly writing more complex expressions. DynamicExpressions provides a more convenient way to create expressions using the parse_expression function, which directly parses a Julia object:\n\nparsed_expr = parse_expression(\n    :(sin(2.0 * x + exp(y + 5.0))); operators=operators, variable_names=variable_names\n)\n\nWe can convert an expression into the primitive AbstractExpressionNode type with get_tree:\n\ntree = get_tree(parsed_expr)\n\nSome AbstractExpression types may choose to store their expression in a different way than simply saving it as one of the fields. For any expression, you can get the raw contents with get_contents:\n\nget_contents(parsed_expr)\n\nSimilarly, you can get the metadata for an expression with get_metadata:\n\nget_metadata(parsed_expr)\n\nThese can be used with with_contents and with_metadata to create new expressions based on the original:\n\nwith_contents(parsed_expr, Node(; op=2, l=get_contents(parsed_expr)))\n\nExpression objects support various operations defined on regular trees, which permits us to overload specific methods with modified behavior. For example, we can count the number of nodes, which simply forwards to the method as it is defined on Node:\n\nnode_count = count_nodes(parsed_expr)\nprintln(\"Number of nodes: $node_count\")\n\nThe [tree_mapreduce] will by default call get_tree to get the tree, so it can be used with any expression type that overloads this method. For example, we can compute the depth of a tree:\n\ntree_mapreduce(\n    leaf -> 1, branch -> 1, (parent, child...) -> parent + max(child...), parsed_expr\n)\n\nWe can also perform more complex operations, like simplification:\n\ncomplex_expr = parse_expression(\n    :((2.0 + x) + 3.0); operators=operators, variable_names=[\"x\"]\n)\nsimplified_expr = combine_operators(copy(complex_expr))\nprintln(\"Original: \", complex_expr)\nprintln(\"Simplified: \", simplified_expr)\n\nAbstractExpression types also have many operators in Base defined, which will automatically look up the matching index in the stored OperatorEnum. This means we can combine expressions like so:\n\nxs = [Expression(Node{Float64}(; feature=i); operators, variable_names) for i in 1:5]\n\nxs[1] + xs[2]\n\nThese have the same type – they simply combine their AbstractExpressionNode objects and ensure the metadata is the same.\n\ntypeof(xs[1] + xs[2])\n\nThis gives us an easy way to quickly construct expressions with minimal memory overhead, and fast evaluation speed:\n\nex = xs[1] * 2.1 - exp(3 * xs[2])\n\nEvaluation:\n\nX = randn(rng, 5, 2)\nex(X)\n\nOr, if we have loaded Zygote, we can differentiate with respect to the variables:\n\nusing Zygote\nex'(X)\n\nOr the constants of the expression:\n\nex'(X; variable=Val(false))\n\nWhich can be used for optimization.\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"#Introduction","page":"Home","title":"Introduction","text":"<img src=\"https://user-images.githubusercontent.com/7593028/196523542-305f3fc2-18d2-41e5-9252-1f96c3d0b7e7.png\" height=\"50%\" width=\"50%\">\n\nRidiculously fast dynamic expressions.\n\n(Image: ) (Image: CI) (Image: Coverage Status) (Image: Aqua QA) (Image: DispatchDoctor)\n\nDynamicExpressions.jl is the backbone of SymbolicRegression.jl and PySR.","category":"section"},{"location":"#Summary","page":"Home","title":"Summary","text":"A dynamic expression is a snippet of code that can change throughout runtime - compilation is not possible! DynamicExpressions.jl does the following:\n\nDefines an enum over user-specified operators.\nUsing this enum, it defines a very lightweight and type-stable data structure for arbitrary expressions.\nIt then generates specialized evaluation kernels for the space of potential operators.\nIt also generates kernels for the first-order derivatives, using Zygote.jl.\nDynamicExpressions.jl can also operate on arbitrary other types (vectors, tensors, symbols, strings, or even unions) - see last part below.\nIt also has import and export functionality with SymbolicUtils.jl.","category":"section"},{"location":"#Example","page":"Home","title":"Example","text":"using DynamicExpressions\n\noperators = OperatorEnum(1 => (cos,), 2 => (+, -, *))\nvariable_names = [\"x1\", \"x2\"]\n\nx1 = Expression(Node{Float64}(feature=1); operators, variable_names)\nx2 = Expression(Node{Float64}(feature=2); operators, variable_names)\n\nexpression = x1 * cos(x2 - 3.2)\n\nX = randn(Float64, 2, 100);\nexpression(X) # 100-element Vector{Float64}","category":"section"},{"location":"#Speed","page":"Home","title":"Speed","text":"First, what happens if we naively use Julia symbols to define and then evaluate this expression?\n\n@btime eval(:(X[1, :] .* cos.(X[2, :] .- 3.2)))\n# 117,000 ns\n\nThis is quite slow, meaning it will be hard to quickly search over the space of expressions. Let's see how DynamicExpressions.jl compares:\n\n@btime expression(X)\n# 607 ns\n\nMuch faster! And we didn't even need to compile it. (Internally, this is calling eval_tree_array(expression, X)). \n\nIf we change expression dynamically with a random number generator, it will have the same performance:\n\n@btime ex(X) setup=(ex = copy(expression); ex.tree.op = rand(1:3) #= random operator in [+, -, *] =#)\n# 640 ns\n\nNow, let's see the performance if we had hard-coded these expressions:\n\nf(X) = X[1, :] .* cos.(X[2, :] .- 3.2)\n@btime f(X)\n# 629 ns\n\nSo, our dynamic expression evaluation is about the same (or even a bit faster) as evaluating a basic hard-coded expression! Let's see if we can optimize the speed of the hard-coded version:\n\nf_optimized(X) = begin\n    y = Vector{Float64}(undef, 100)\n    @inbounds @simd for i=1:100\n        y[i] = X[1, i] * cos(X[2, i] - 3.2)\n    end\n    y\nend\n@btime f_optimized(X)\n# 526 ns\n\nThe DynamicExpressions.jl version is only 25% slower than one which has been optimized by hand into a single SIMD kernel! Not bad at all.\n\nMore importantly: we can change expression throughout runtime, and expect the same performance. This makes this data structure ideal for symbolic regression and other evaluation-based searches over expression trees.","category":"section"},{"location":"#Derivatives","page":"Home","title":"Derivatives","text":"We can also compute gradients with the same speed:\n\nusing Zygote  # trigger extension\n\noperators = OperatorEnum(1 => (cos,), 2 => (+, -, *))\nvariable_names = [\"x1\", \"x2\"]\nx1, x2 = (Expression(Node{Float64}(feature=i); operators, variable_names) for i in 1:2)\n\nexpression = x1 * cos(x2 - 3.2)\n\nWe can take the gradient with respect to inputs with simply the ' character:\n\ngrad = expression'(X)\n\nThis is quite fast:\n\n@btime expression'(X)\n# 2333 ns\n\nand again, we can change this expression at runtime, without loss in performance!\n\n@btime ex'(X) setup=(ex = copy(expression); ex.tree.op = rand(1:3))\n# 2333 ns\n\nInternally, this is calling the eval_grad_tree_array function, which performs forward-mode automatic differentiation on the expression tree with Zygote-compiled kernels. We can also compute the derivative with respect to constants:\n\nresult, grad, did_finish = eval_grad_tree_array(expression, X; variable=false)","category":"section"},{"location":"#Generic-types","page":"Home","title":"Generic types","text":"Does this work for only scalar operators on real numbers, or will it work for MyCrazyType?\n\nI'm so glad you asked. DynamicExpressions.jl actually will work for arbitrary types! However, to work on operators other than real scalars, you need to use the GenericOperatorEnum <: AbstractOperatorEnum instead of the normal OperatorEnum. Let's try it with strings!\n\n_x1 = Node{String}(; feature=1) \n\nThis node, will be used to index input data (whatever it may be) with either data[feature] (1D abstract arrays) or selectdim(data, 1, feature) (ND abstract arrays). Let's now define some operators to use:\n\nusing DynamicExpressions: @declare_expression_operator\n\nmy_string_func(x::String) = \"ello $x\"\n@declare_expression_operator(my_string_func, 1)\n\noperators = GenericOperatorEnum(1 => (my_string_func,), 2 => (*,))\n\nx1 = Expression(_x1; operators, variable_names)\n\nNow, let's create an expression:\n\nexpression = \"H\" * my_string_func(x1)\n# ^ `(H * my_string_func(x1))`\n\nexpression([\"World!\", \"Me?\"])\n# Hello World!\n\nSo indeed it works for arbitrary types. It is a bit slower due to the potential for type instability, but it's not too bad:\n\n@btime expression([\"Hello\", \"Me?\"])\n# 103.105 ns (4 allocations: 144 bytes)","category":"section"},{"location":"#Tensors","page":"Home","title":"Tensors","text":"Does this work for tensors, or even unions of scalars and tensors?\n\nAlso yes! Let's see:\n\nusing DynamicExpressions\nusing DynamicExpressions: @declare_expression_operator\n\nT = Union{Float64,Vector{Float64}}\n\n# Some operators on tensors (multiple dispatch can be used for different behavior!)\nvec_add(x, y) = x .+ y\nvec_square(x) = x .* x\n\n# Enable these operators for DynamicExpressions.jl:\n@declare_expression_operator(vec_add, 2)\n@declare_expression_operator(vec_square, 1)\n\n# Set up an operator enum:\noperators = GenericOperatorEnum(1 => (vec_square,), 2 => (vec_add,))\n\n# Construct the expression:\nvariable_names = [\"x1\"]\nc1 = Expression(Node{T}(; val=0.0); operators, variable_names)  # Scalar constant\nc2 = Expression(Node{T}(; val=[1.0, 2.0, 3.0]); operators, variable_names)  # Vector constant\nx1 = Expression(Node{T}(; feature=1); operators, variable_names)\n\nexpression = vec_add(vec_add(vec_square(x1), c2), c1)\n\nX = [[-1.0, 5.2, 0.1], [0.0, 0.0, 0.0]]\n\n# Evaluate!\nexpression(X)  # [2.0, 29.04, 3.01]\n\nNote that if an operator is not defined for the particular input, nothing will be returned instead.\n\nThis is all still pretty fast, too:\n\n@btime expression(X)\n# 461.086 ns (13 allocations: 448 bytes)\n@btime eval(:(vec_add(vec_add(vec_square(X[1]), [1.0, 2.0, 3.0]), 0.0)))\n# 115,000 ns","category":"section"},{"location":"#Contents","page":"Home","title":"Contents","text":"","category":"section"},{"location":"utils/#Node-utilities","page":"Utils","title":"Node utilities","text":"","category":"section"},{"location":"utils/#Base","page":"Utils","title":"Base","text":"Various functions in Base are overloaded to treat an AbstractNode as a collection of its nodes.","category":"section"},{"location":"utils/#Printing","page":"Utils","title":"Printing","text":"Trees are printed using the string_tree function, which is very configurable:\n\nThe standard show and print methods will use the most recently-created OperatorEnum in a string_tree.","category":"section"},{"location":"utils/#Sampling","page":"Utils","title":"Sampling","text":"There are also methods for random sampling of nodes:","category":"section"},{"location":"utils/#Internal-utilities","page":"Utils","title":"Internal utilities","text":"Almost all node utilities are crafted using the tree_mapreduce function, which evaluates a mapreduce over a tree-like (or graph-like) structure:\n\nVarious other utility functions include the following:","category":"section"},{"location":"utils/#Base.copy-Tuple{AbstractExpressionNode}","page":"Utils","title":"Base.copy","text":"copy(tree::AbstractExpressionNode; break_sharing::Val=Val(false))\n\nCopy a node, recursively copying all children nodes. This is more efficient than the built-in copy.\n\nIf break_sharing is set to Val(true), sharing in a tree will be ignored.\n\n\n\n\n\n","category":"method"},{"location":"utils/#Base.filter-Tuple{Function, AbstractNode}","page":"Utils","title":"Base.filter","text":"filter(f::Function, tree::AbstractNode; break_sharing::Val=Val(false))\n\nFilter nodes of a tree, returning a flat array of the nodes for which the function returns true.\n\n\n\n\n\n","category":"method"},{"location":"utils/#Base.count-Tuple{Function, AbstractNode}","page":"Utils","title":"Base.count","text":"count(f::F, tree::AbstractNode; init=0, break_sharing::Val{BS}=Val(false)) where {F<:Function,BS}\n\nCount the number of nodes in a tree for which the function returns true.\n\n\n\n\n\n","category":"method"},{"location":"utils/#Base.foreach-Tuple{Function, AbstractNode}","page":"Utils","title":"Base.foreach","text":"foreach(f, c...) -> Nothing\n\nCall function f on each element of iterable c. For multiple iterable arguments, f is called elementwise, and iteration stops when any iterator is finished.\n\nforeach should be used instead of map when the results of f are not needed, for example in foreach(println, array).\n\nExamples\n\njulia> tri = 1:3:7; res = Int[];\n\njulia> foreach(x -> push!(res, x^2), tri)\n\njulia> res\n3-element Vector{Int64}:\n  1\n 16\n 49\n\njulia> foreach((x, y) -> println(x, \" with \", y), tri, 'a':'z')\n1 with a\n4 with b\n7 with c\n\n\n\n\n\nforeach(f::Function, tree::AbstractNode; break_sharing::Val=Val(false))\n\nApply a function to each node in a tree without returning the results.\n\n\n\n\n\n","category":"method"},{"location":"utils/#Base.sum-Union{Tuple{F}, Tuple{F, AbstractNode}} where F<:Function","page":"Utils","title":"Base.sum","text":"sum(f::Function, tree::AbstractNode; result_type=Undefined, f_on_shared=_default_shared_aggregation, break_sharing::Val{BS}=Val(false)) where {F<:Function,BS}\n\nSum the results of a function over a tree. For graphs with shared nodes such as GraphNode, the function f_on_shared is called on the result of each shared node. This is used to avoid double-counting shared nodes (default behavior).\n\n\n\n\n\n","category":"method"},{"location":"utils/#Base.mapreduce-Union{Tuple{G}, Tuple{F}, Tuple{F, G, AbstractNode}} where {F<:Function, G<:Function}","page":"Utils","title":"Base.mapreduce","text":"mapreduce(f::Function, op::Function, tree::AbstractNode; result_type, f_on_shared, break_sharing)\n\nMap a function over a tree and aggregate the result using an operator op.\n\n\n\n\n\n","category":"method"},{"location":"utils/#Base.any-Union{Tuple{F}, Tuple{F, AbstractNode}} where F<:Function","page":"Utils","title":"Base.any","text":"any(f::Function, tree::AbstractNode)\n\nReduce a flag function over a tree, returning true if the function returns true for any node. By using this instead of tree_mapreduce, we can take advantage of early exits.\n\n\n\n\n\n","category":"method"},{"location":"utils/#Base.all-Union{Tuple{F}, Tuple{F, AbstractNode}} where F<:Function","page":"Utils","title":"Base.all","text":"all(f::Function, tree::AbstractNode)\n\nReduce a flag function over a tree, returning true if the function returns true for all nodes, false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"utils/#Base.map-Union{Tuple{RT}, Tuple{F}, Tuple{F, AbstractNode}, Tuple{F, AbstractNode, Type{RT}}} where {F<:Function, RT}","page":"Utils","title":"Base.map","text":"map(f::F, tree::AbstractNode, result_type::Type{RT}=Nothing; break_sharing::Val{BS}=Val(false)) where {F<:Function,RT,BS}\n\nMap a function over a tree and return a flat array of the results in depth-first order. Pre-specifying the result_type of the function can be used to avoid extra allocations.\n\n\n\n\n\n","category":"method"},{"location":"utils/#Base.hash-Union{Tuple{T}, Tuple{AbstractExpressionNode{T}, UInt64}} where T","page":"Utils","title":"Base.hash","text":"hash(tree::AbstractExpressionNode{T}[, h::UInt]; break_sharing::Val=Val(false)) where {T}\n\nCompute a hash of a tree. This will compute a hash differently if nodes are shared in a tree. This is ignored if break_sharing is set to Val(true).\n\n\n\n\n\n","category":"method"},{"location":"utils/#DynamicExpressions.StringsModule.string_tree-Tuple{Node, AbstractOperatorEnum}","page":"Utils","title":"DynamicExpressions.StringsModule.string_tree","text":"string_tree(\n    tree::AbstractExpressionNode{T},\n    operators::Union{AbstractOperatorEnum,Nothing}=nothing;\n    f_variable::F1=string_variable,\n    f_constant::F2=string_constant,\n    variable_names::Union{Array{String,1},Nothing}=nothing,\n    # Deprecated\n    varMap=nothing,\n)::String where {T,F1<:Function,F2<:Function}\n\nConvert an equation to a string.\n\nArguments\n\ntree: the tree to convert to a string\noperators: the operators used to define the tree\n\nKeyword Arguments\n\nf_variable: (optional) function to convert a variable to a string, with arguments (feature::UInt8, variable_names).\nf_constant: (optional) function to convert a constant to a string, with arguments (val,)\nvariable_names::Union{Array{String, 1}, Nothing}=nothing: (optional) what variables to print for each feature.\n\n\n\n\n\n","category":"method"},{"location":"utils/#DynamicExpressions.RandomModule.NodeSampler","page":"Utils","title":"DynamicExpressions.RandomModule.NodeSampler","text":"NodeSampler(; tree, filter::Function=Returns(true), weighting::Union{Nothing,Function}=nothing, break_sharing::Val=Val(false))\n\nDefines a sampler of nodes in a tree.\n\nArguments\n\ntree: The tree to sample nodes from. For a regular Node, nodes are sampled uniformly. For a GraphNode, nodes are also sampled uniformly (e.g., in sin(x) + {x}, the x has equal probability of being sampled from the sin or the + node, because it is shared), unless break_sharing is set to Val(true).\nfilter::Function: A function that takes a node and returns a boolean indicating whether the node should be sampled. Defaults to Returns(true).\nweighting::Union{Nothing,Function}: A function that takes a node and returns a weight for the node, if it passes the filter, proportional to the probability of sampling the node. If nothing, all nodes are sampled uniformly.\nbreak_sharing::Val: If Val(true), the sampler will break sharing in the tree, and sample nodes uniformly from the tree.\n\n\n\n\n\n","category":"type"},{"location":"utils/#Base.rand-Tuple{AbstractRNG, AbstractNode}","page":"Utils","title":"Base.rand","text":"rand(rng::AbstractRNG, tree::AbstractNode)\n\nSample a node from a tree according to the default sampler NodeSampler(; tree).\n\n\n\n\n\n","category":"method"},{"location":"utils/#Base.rand-Union{Tuple{F}, Tuple{N}, Tuple{AbstractRNG, NodeSampler{N, F, Nothing}}} where {N, F}","page":"Utils","title":"Base.rand","text":"rand(rng::AbstractRNG, sampler::NodeSampler)\n\nSample a node from a tree according to the sampler sampler.\n\n\n\n\n\n","category":"method"},{"location":"utils/#DynamicExpressions.NodeModule.tree_mapreduce","page":"Utils","title":"DynamicExpressions.NodeModule.tree_mapreduce","text":"tree_mapreduce(\n    f::Function,\n    [f_branch::Function,]\n    op::Function,\n    tree::AbstractNode,\n    [result_type::Type=Undefined];\n    f_on_shared::Function=(result, is_shared) -> result,\n    break_sharing::Val=Val(false),\n)\n\nMap a function over a tree and aggregate the result using an operator op. op should be defined with inputs (parent, child...) -> so that it can aggregate both unary and binary operators. op will not be called for leafs of the tree. This differs from a normal mapreduce in that it allows different treatment for parent nodes than children nodes. If this is not necessary, you may use the regular mapreduce instead. The argument break_sharing can be used to break connections in a GraphNode.\n\nYou can also provide separate functions for leaf (variable/constant) nodes and branch (operator) nodes.\n\nExamples\n\njulia> operators = OperatorEnum(2 => (+, *));\n\njulia> tree = Node(; feature=1) + Node(; feature=2) * 3.2;\n\njulia> tree_mapreduce(t -> 1, +, tree)  # count nodes. (regular mapreduce also works)\n5\n\njulia> tree_mapreduce(t -> 1, (p, c...) -> p + max(c...), tree)  # compute depth. regular mapreduce would fail!\n5\n\njulia> tree_mapreduce(vcat, tree) do t\n    t.degree == 2 ? [t.op] : UInt8[]\nend  # Get list of binary operators used. (regular mapreduce also works)\n2-element Vector{UInt8}:\n 1\n 2\n\njulia> tree_mapreduce(vcat, tree) do t\n    (t.degree == 0 && t.constant) ? [t.val] : Float64[]\nend  # Get list of constants. (regular mapreduce also works)\n1-element Vector{Float64}:\n 3.2\n\n\n\n\n\n","category":"function"},{"location":"utils/#DynamicExpressions.NodeModule.filter_map","page":"Utils","title":"DynamicExpressions.NodeModule.filter_map","text":"filter_map(filter_fnc::Function, map_fnc::Function, tree::AbstractNode, result_type::Type, break_sharing::Val=Val(false))\n\nA faster equivalent to map(map_fnc, filter(filter_fnc, tree)) that avoids the intermediate allocation. However, using this requires specifying the result_type of map_fnc so the resultant array can be preallocated.\n\n\n\n\n\n","category":"function"},{"location":"utils/#DynamicExpressions.NodeModule.filter_map!","page":"Utils","title":"DynamicExpressions.NodeModule.filter_map!","text":"filter_map!(filter_fnc::Function, map_fnc::Function, stack::Vector{GT}, tree::AbstractNode)\n\nEquivalent to filter_map, but stores the results in a preallocated array.\n\n\n\n\n\n","category":"function"}]
}
