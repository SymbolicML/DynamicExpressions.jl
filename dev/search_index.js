var documenterSearchIndex = {"docs":
[{"location":"eval/#Evaluation-and-Derivatives","page":"Evaluation & Derivatives","title":"Evaluation & Derivatives","text":"","category":"section"},{"location":"eval/#Evaluation","page":"Evaluation & Derivatives","title":"Evaluation","text":"","category":"section"},{"location":"eval/","page":"Evaluation & Derivatives","title":"Evaluation & Derivatives","text":"Given an expression tree specified with a Node type, you may evaluate the expression over an array of data with the following command:","category":"page"},{"location":"eval/","page":"Evaluation & Derivatives","title":"Evaluation & Derivatives","text":"eval_tree_array(tree::Node{T}, cX::AbstractMatrix{T}, operators::OperatorEnum) where {T<:Number}","category":"page"},{"location":"eval/#DynamicExpressions.EvaluateEquationModule.eval_tree_array-Union{Tuple{T}, Tuple{Node{T}, AbstractMatrix{T}, OperatorEnum}} where T<:Number","page":"Evaluation & Derivatives","title":"DynamicExpressions.EvaluateEquationModule.eval_tree_array","text":"eval_tree_array(tree::AbstractExpressionNode, cX::AbstractMatrix{T}, operators::OperatorEnum; turbo::Union{Bool,Val}=Val(false))\n\nEvaluate a binary tree (equation) over a given input data matrix. The operators contain all of the operators used. This function fuses doublets and triplets of operations for lower memory usage.\n\nArguments\n\ntree::AbstractExpressionNode: The root node of the tree to evaluate.\ncX::AbstractMatrix{T}: The input data to evaluate the tree on.\noperators::OperatorEnum: The operators used in the tree.\nturbo::Union{Bool,Val}: Use LoopVectorization.@turbo for faster evaluation.\n\nReturns\n\n(output, complete)::Tuple{AbstractVector{T}, Bool}: the result,   which is a 1D array, as well as if the evaluation completed   successfully (true/false). A false complete means an infinity   or nan was encountered, and a large loss should be assigned   to the equation.\n\nNotes\n\nThis function can be represented by the following pseudocode:\n\ndef eval(current_node)\n    if current_node is leaf\n        return current_node.value\n    elif current_node is degree 1\n        return current_node.operator(eval(current_node.left_child))\n    else\n        return current_node.operator(eval(current_node.left_child), eval(current_node.right_child))\n\nThe bulk of the code is for optimizations and pre-emptive NaN/Inf checks, which speed up evaluation significantly.\n\n\n\n\n\n","category":"method"},{"location":"eval/","page":"Evaluation & Derivatives","title":"Evaluation & Derivatives","text":"Assuming you are only using a single OperatorEnum, you can also use the following shorthand by using the expression as a function:","category":"page"},{"location":"eval/","page":"Evaluation & Derivatives","title":"Evaluation & Derivatives","text":"    (tree::Node)(X::AbstractMatrix, operators::GenericOperatorEnum; throw_errors::Bool=true)\n\n# Arguments\n- `X::AbstractArray`: The input data to evaluate the tree on.\n- `operators::GenericOperatorEnum`: The operators used in the tree.\n- `throw_errors::Bool=true`: Whether to throw errors\n    if they occur during evaluation. Otherwise,\n    MethodErrors will be caught before they happen and\n    evaluation will return `nothing`,\n    rather than throwing an error. This is useful in cases\n    where you are unsure if a particular tree is valid or not,\n    and would prefer to work with `nothing` as an output.\n\n# Returns\n- `output`: the result of the evaluation.\n    If evaluation failed, `nothing` will be returned for the first argument.\n    A `false` complete means an operator was called on input types\n    that it was not defined for. You can change this behavior by\n    setting `throw_errors=false`.","category":"page"},{"location":"eval/","page":"Evaluation & Derivatives","title":"Evaluation & Derivatives","text":"For example,","category":"page"},{"location":"eval/","page":"Evaluation & Derivatives","title":"Evaluation & Derivatives","text":"using DynamicExpressions\n\noperators = OperatorEnum(; binary_operators=[+, -, *], unary_operators=[cos])\ntree = Node(; feature=1) * cos(Node(; feature=2) - 3.2)\n\ntree([1 2 3; 4 5 6.], operators)","category":"page"},{"location":"eval/","page":"Evaluation & Derivatives","title":"Evaluation & Derivatives","text":"This is possible because when you call OperatorEnum, it automatically re-defines (::Node)(X) to call the evaluation operation with the given operators loaded. It also re-definesprint,show, and the various operators, to work with theNode` type.","category":"page"},{"location":"eval/","page":"Evaluation & Derivatives","title":"Evaluation & Derivatives","text":"warning: Warning\nThe Node type does not know about which OperatorEnum you used to create it. Thus, if you define an expression with one OperatorEnum, and then try to evaluate it or print it with a different OperatorEnum, you will get undefined behavior!","category":"page"},{"location":"eval/","page":"Evaluation & Derivatives","title":"Evaluation & Derivatives","text":"You can also work with arbitrary types, by defining a GenericOperatorEnum instead. The notation is the same for eval_tree_array, though it will return nothing when it can't find a method, and not do any NaN checks:","category":"page"},{"location":"eval/","page":"Evaluation & Derivatives","title":"Evaluation & Derivatives","text":"eval_tree_array(tree::Node, cX::AbstractMatrix, operators::GenericOperatorEnum; throw_errors::Bool=true)","category":"page"},{"location":"eval/#DynamicExpressions.EvaluateEquationModule.eval_tree_array-Tuple{Node, AbstractMatrix, GenericOperatorEnum}","page":"Evaluation & Derivatives","title":"DynamicExpressions.EvaluateEquationModule.eval_tree_array","text":"eval_tree_array(tree::AbstractExpressionNode, cX::AbstractMatrix, operators::GenericOperatorEnum; throw_errors::Bool=true)\n\nEvaluate a generic binary tree (equation) over a given input data, whatever that input data may be. The operators enum contains all of the operators used. Unlike eval_tree_array with the normal OperatorEnum, the array cX is sliced only along the first dimension. i.e., if cX is a vector, then the output of a feature node will be a scalar. If cX is a 3D tensor, then the output of a feature node will be a 2D tensor. Note also that tree.feature will index along the first axis of cX.\n\nHowever, there is no requirement about input and output types in general. You may set up your tree such that some operator nodes work on tensors, while other operator nodes work on scalars. eval_tree_array will simply return nothing if a given operator is not defined for the given input type.\n\nThis function can be represented by the following pseudocode:\n\nfunction eval(current_node)\n    if current_node is leaf\n        return current_node.value\n    elif current_node is degree 1\n        return current_node.operator(eval(current_node.left_child))\n    else\n        return current_node.operator(eval(current_node.left_child), eval(current_node.right_child))\n\nArguments\n\ntree::AbstractExpressionNode: The root node of the tree to evaluate.\ncX::AbstractArray: The input data to evaluate the tree on.\noperators::GenericOperatorEnum: The operators used in the tree.\nthrow_errors::Bool=true: Whether to throw errors   if they occur during evaluation. Otherwise,   MethodErrors will be caught before they happen and    evaluation will return nothing,   rather than throwing an error. This is useful in cases   where you are unsure if a particular tree is valid or not,   and would prefer to work with nothing as an output.\n\nReturns\n\n(output, complete)::Tuple{Any, Bool}: the result,   as well as if the evaluation completed successfully (true/false).   If evaluation failed, nothing will be returned for the first argument.   A false complete means an operator was called on input types   that it was not defined for.\n\n\n\n\n\n","category":"method"},{"location":"eval/","page":"Evaluation & Derivatives","title":"Evaluation & Derivatives","text":"Likewise for the shorthand notation:","category":"page"},{"location":"eval/","page":"Evaluation & Derivatives","title":"Evaluation & Derivatives","text":"    (tree::Node)(X::AbstractMatrix, operators::GenericOperatorEnum; throw_errors::Bool=true)\n\n# Arguments\n- `X::AbstractArray`: The input data to evaluate the tree on.\n- `operators::GenericOperatorEnum`: The operators used in the tree.\n- `throw_errors::Bool=true`: Whether to throw errors\n    if they occur during evaluation. Otherwise,\n    MethodErrors will be caught before they happen and\n    evaluation will return `nothing`,\n    rather than throwing an error. This is useful in cases\n    where you are unsure if a particular tree is valid or not,\n    and would prefer to work with `nothing` as an output.\n\n# Returns\n- `output`: the result of the evaluation.\n    If evaluation failed, `nothing` will be returned for the first argument.\n    A `false` complete means an operator was called on input types\n    that it was not defined for. You can change this behavior by\n    setting `throw_errors=false`.","category":"page"},{"location":"eval/#Derivatives","page":"Evaluation & Derivatives","title":"Derivatives","text":"","category":"section"},{"location":"eval/","page":"Evaluation & Derivatives","title":"Evaluation & Derivatives","text":"DynamicExpressions.jl can efficiently compute first-order derivatives of expressions with respect to variables or constants. This is done using either eval_diff_tree_array, to compute derivative with respect to a single variable, or with eval_grad_tree_array, to compute the gradient with respect all variables (or, all constants). Both use forward-mode automatic, but use Zygote.jl to compute derivatives of each operator, so this is very efficient.","category":"page"},{"location":"eval/","page":"Evaluation & Derivatives","title":"Evaluation & Derivatives","text":"eval_diff_tree_array(tree::Node{T}, cX::AbstractMatrix{T}, operators::OperatorEnum, direction::Integer) where {T<:Number}\neval_grad_tree_array(tree::Node{T}, cX::AbstractMatrix{T}, operators::OperatorEnum; turbo::Bool=false, variable::Bool=false) where {T<:Number}","category":"page"},{"location":"eval/#DynamicExpressions.EvaluateEquationDerivativeModule.eval_diff_tree_array-Union{Tuple{T}, Tuple{Node{T}, AbstractMatrix{T}, OperatorEnum, Integer}} where T<:Number","page":"Evaluation & Derivatives","title":"DynamicExpressions.EvaluateEquationDerivativeModule.eval_diff_tree_array","text":"eval_diff_tree_array(tree::AbstractExpressionNode{T}, cX::AbstractMatrix{T}, operators::OperatorEnum, direction::Integer; turbo::Bool=false)\n\nCompute the forward derivative of an expression, using a similar structure and optimization to evaltreearray. direction is the index of a particular variable in the expression. e.g., direction=1 would indicate derivative with respect to x1.\n\nArguments\n\ntree::AbstractExpressionNode: The expression tree to evaluate.\ncX::AbstractMatrix{T}: The data matrix, with each column being a data point.\noperators::OperatorEnum: The operators used to create the tree.\ndirection::Integer: The index of the variable to take the derivative with respect to.\nturbo::Union{Val,Bool}: Use LoopVectorization.@turbo for faster evaluation.\n\nReturns\n\n(evaluation, derivative, complete)::Tuple{AbstractVector{T}, AbstractVector{T}, Bool}: the normal evaluation,   the derivative, and whether the evaluation completed as normal (or encountered a nan or inf).\n\n\n\n\n\n","category":"method"},{"location":"eval/#DynamicExpressions.EvaluateEquationDerivativeModule.eval_grad_tree_array-Union{Tuple{T}, Tuple{Node{T}, AbstractMatrix{T}, OperatorEnum}} where T<:Number","page":"Evaluation & Derivatives","title":"DynamicExpressions.EvaluateEquationDerivativeModule.eval_grad_tree_array","text":"eval_grad_tree_array(tree::AbstractExpressionNode{T}, cX::AbstractMatrix{T}, operators::OperatorEnum; variable::Bool=false, turbo::Bool=false)\n\nCompute the forward-mode derivative of an expression, using a similar structure and optimization to evaltreearray. variable specifies whether we should take derivatives with respect to features (i.e., cX), or with respect to every constant in the expression.\n\nArguments\n\ntree::AbstractExpressionNode{T}: The expression tree to evaluate.\ncX::AbstractMatrix{T}: The data matrix, with each column being a data point.\noperators::OperatorEnum: The operators used to create the tree.\nvariable::Bool: Whether to take derivatives with respect to features (i.e., cX - with variable=true),   or with respect to every constant in the expression (variable=false).\nturbo::Bool: Use LoopVectorization.@turbo for faster evaluation. Currently this does not have   any effect.\n\nReturns\n\n(evaluation, gradient, complete)::Tuple{AbstractVector{T}, AbstractMatrix{T}, Bool}: the normal evaluation,   the gradient, and whether the evaluation completed as normal (or encountered a nan or inf).\n\n\n\n\n\n","category":"method"},{"location":"eval/","page":"Evaluation & Derivatives","title":"Evaluation & Derivatives","text":"You can compute gradients this with shorthand notation as well (which by default computes gradients with respect to input matrix, rather than constants).","category":"page"},{"location":"eval/","page":"Evaluation & Derivatives","title":"Evaluation & Derivatives","text":"    (tree::Node{T})'(X::AbstractMatrix{T}, operators::OperatorEnum; turbo::Bool=false, variable::Bool=true)\n\nCompute the forward-mode derivative of an expression, using a similar\nstructure and optimization to eval_tree_array. `variable` specifies whether\nwe should take derivatives with respect to features (i.e., X), or with respect\nto every constant in the expression.\n\n# Arguments\n- `X::AbstractMatrix{T}`: The data matrix, with each column being a data point.\n- `operators::OperatorEnum`: The operators used to create the `tree`.\n- `variable::Bool`: Whether to take derivatives with respect to features (i.e., `X` - with `variable=true`),\n    or with respect to every constant in the expression (`variable=false`).\n- `turbo::Bool`: Use `LoopVectorization.@turbo` for faster evaluation.\n\n# Returns\n\n- `(evaluation, gradient, complete)::Tuple{AbstractVector{T}, AbstractMatrix{T}, Bool}`: the normal evaluation,\n    the gradient, and whether the evaluation completed as normal (or encountered a nan or inf).","category":"page"},{"location":"eval/","page":"Evaluation & Derivatives","title":"Evaluation & Derivatives","text":"Alternatively, you can compute higher-order derivatives by using ForwardDiff on the function differentiable_eval_tree_array, although this will be slower.","category":"page"},{"location":"eval/","page":"Evaluation & Derivatives","title":"Evaluation & Derivatives","text":"differentiable_eval_tree_array(tree::Node{T}, cX::AbstractMatrix{T}, operators::OperatorEnum) where {T<:Number}","category":"page"},{"location":"eval/#DynamicExpressions.EvaluateEquationModule.differentiable_eval_tree_array-Union{Tuple{T}, Tuple{Node{T}, AbstractMatrix{T}, OperatorEnum}} where T<:Number","page":"Evaluation & Derivatives","title":"DynamicExpressions.EvaluateEquationModule.differentiable_eval_tree_array","text":"differentiable_eval_tree_array(tree::AbstractExpressionNode, cX::AbstractMatrix, operators::OperatorEnum)\n\nEvaluate an expression tree in a way that can be auto-differentiated.\n\n\n\n\n\n","category":"method"},{"location":"eval/#Enzyme","page":"Evaluation & Derivatives","title":"Enzyme","text":"","category":"section"},{"location":"eval/","page":"Evaluation & Derivatives","title":"Evaluation & Derivatives","text":"DynamicExpressions.jl also supports automatic differentiation with Enzyme.jl. Note that this is extremely experimental. You should expect to see occasional incorrect gradients. Be sure to explicitly verify gradients are correct for a particular space of operators (e.g., with finite differences).","category":"page"},{"location":"eval/","page":"Evaluation & Derivatives","title":"Evaluation & Derivatives","text":"Let's look at an example. First, let's create a tree:","category":"page"},{"location":"eval/","page":"Evaluation & Derivatives","title":"Evaluation & Derivatives","text":"using DynamicExpressions\n\noperators = OperatorEnum(binary_operators=(+, -, *, /), unary_operators=(cos, sin))\n\nx1 = Node{Float64}(feature=1)\nx2 = Node{Float64}(feature=2)\n\ntree = 0.5 * x1 + cos(x2 - 0.2)","category":"page"},{"location":"eval/","page":"Evaluation & Derivatives","title":"Evaluation & Derivatives","text":"Now, say we want to take the derivative of this expression with respect to x1 and x2. First, let's evaluate it normally:","category":"page"},{"location":"eval/","page":"Evaluation & Derivatives","title":"Evaluation & Derivatives","text":"X = [1.0 2.0 3.0; 4.0 5.0 6.0]  # 2x3 matrix (2 features, 3 rows)\n\ntree(X, operators)","category":"page"},{"location":"eval/","page":"Evaluation & Derivatives","title":"Evaluation & Derivatives","text":"Now, let's use Enzyme.jl to compute the derivative of the outputs with respect to x1 and x2, using reverse-mode autodiff:","category":"page"},{"location":"eval/","page":"Evaluation & Derivatives","title":"Evaluation & Derivatives","text":"using Enzyme\n\nfunction my_loss_function(tree, X, operators)\n    # Get the outputs\n    y = tree(X, operators)\n    # Sum them (so we can take a gradient, rather than a jacobian)\n    return sum(y)\nend\n\n\ndX = begin\n    storage=zero(X)\n    autodiff(\n        Reverse,\n        my_loss_function,\n        Active,\n        ## Actual arguments to function:\n        Const(tree),\n        Duplicated(X, storage),\n        Const(operators),\n    )\n    storage\nend","category":"page"},{"location":"eval/","page":"Evaluation & Derivatives","title":"Evaluation & Derivatives","text":"This will get returned as","category":"page"},{"location":"eval/","page":"Evaluation & Derivatives","title":"Evaluation & Derivatives","text":" 2×3 Matrix{Float64}:\n  0.5       0.5       0.5\n  0.611858  0.996165  0.464602","category":"page"},{"location":"eval/","page":"Evaluation & Derivatives","title":"Evaluation & Derivatives","text":"which one can confirm is the correct gradient!","category":"page"},{"location":"eval/","page":"Evaluation & Derivatives","title":"Evaluation & Derivatives","text":"This will take a while the first time you run it, as Enzyme needs to take the gradients of the actual LLVM IR code. Subsequent runs won't spend any time compiling and be much faster.","category":"page"},{"location":"eval/","page":"Evaluation & Derivatives","title":"Evaluation & Derivatives","text":"Some general notes about this:","category":"page"},{"location":"eval/","page":"Evaluation & Derivatives","title":"Evaluation & Derivatives","text":"We want to take a reverse-mode gradient, so we pass Reverse to autodiff.\nSince we want to take the gradient of the output of my_loss_function, we declare Active as the third argument.\nFollowing this, we pass our actual arguments to the function.\nObjects which we don't want to take gradients with respect to,  and also don't temporarily store any data during the computation  (such as tree and operators here) should be wrapped with Const.\nObjects which we wish to take derivatives with respect to, we need to use   Duplicated, and explicitly create a copy of it, with all numerical values   set to zero. Enzyme will then store the derivatives in this object.","category":"page"},{"location":"eval/","page":"Evaluation & Derivatives","title":"Evaluation & Derivatives","text":"Note that you should never use anything other than turbo=Val(false) with Enzyme, as Enzyme and LoopVectorization are not compatible, and will cause a segfault. Even using turbo=false will not work, because it would cause Enzyme to trace the (unused) LoopVectorization code!","category":"page"},{"location":"","page":"Contents","title":"Contents","text":"<div align=\"center\">","category":"page"},{"location":"","page":"Contents","title":"Contents","text":"<img src=\"https://user-images.githubusercontent.com/7593028/196523542-305f3fc2-18d2-41e5-9252-1f96c3d0b7e7.png\" height=\"50%\" width=\"50%\"></img>","category":"page"},{"location":"","page":"Contents","title":"Contents","text":"Ridiculously fast dynamic expressions.","category":"page"},{"location":"","page":"Contents","title":"Contents","text":"(Image: ) (Image: CI) (Image: Coverage Status) (Image: Aqua QA)","category":"page"},{"location":"","page":"Contents","title":"Contents","text":"DynamicExpressions.jl is the backbone of SymbolicRegression.jl and PySR.","category":"page"},{"location":"","page":"Contents","title":"Contents","text":"</div>","category":"page"},{"location":"#Summary","page":"Contents","title":"Summary","text":"","category":"section"},{"location":"","page":"Contents","title":"Contents","text":"A dynamic expression is a snippet of code that can change throughout runtime - compilation is not possible! DynamicExpressions.jl does the following:","category":"page"},{"location":"","page":"Contents","title":"Contents","text":"Defines an enum over user-specified operators.\nUsing this enum, it defines a very lightweight and type-stable data structure for arbitrary expressions.\nIt then generates specialized evaluation kernels for the space of potential operators.\nIt also generates kernels for the first-order derivatives, using Zygote.jl.\nDynamicExpressions.jl can also operate on arbitrary other types (vectors, tensors, symbols, strings, or even unions) - see last part below.","category":"page"},{"location":"","page":"Contents","title":"Contents","text":"It also has import and export functionality with SymbolicUtils.jl, so you can move your runtime expression into a CAS!","category":"page"},{"location":"#Example","page":"Contents","title":"Example","text":"","category":"section"},{"location":"","page":"Contents","title":"Contents","text":"using DynamicExpressions\n\noperators = OperatorEnum(; binary_operators=[+, -, *], unary_operators=[cos])\n\nx1 = Node(; feature=1)\nx2 = Node(; feature=2)\n\nexpression = x1 * cos(x2 - 3.2)\n\nX = randn(Float64, 2, 100);\nexpression(X, operators) # 100-element Vector{Float64}","category":"page"},{"location":"","page":"Contents","title":"Contents","text":"(We can construct this expression with normal operators, since calling OperatorEnum() will @eval new functions on Node that use the specified enum.)","category":"page"},{"location":"#Speed","page":"Contents","title":"Speed","text":"","category":"section"},{"location":"","page":"Contents","title":"Contents","text":"First, what happens if we naively use Julia symbols to define and then evaluate this expression?","category":"page"},{"location":"","page":"Contents","title":"Contents","text":"@btime eval(:(X[1, :] .* cos.(X[2, :] .- 3.2)))\n# 117,000 ns","category":"page"},{"location":"","page":"Contents","title":"Contents","text":"This is quite slow, meaning it will be hard to quickly search over the space of expressions. Let's see how DynamicExpressions.jl compares:","category":"page"},{"location":"","page":"Contents","title":"Contents","text":"@btime expression(X, operators)\n# 693 ns","category":"page"},{"location":"","page":"Contents","title":"Contents","text":"Much faster! And we didn't even need to compile it. (Internally, this is calling eval_tree_array(expression, X, operators)). ","category":"page"},{"location":"","page":"Contents","title":"Contents","text":"If we change expression dynamically with a random number generator, it will have the same performance:","category":"page"},{"location":"","page":"Contents","title":"Contents","text":"@btime begin\n    expression.op = rand(1:3)  # random operator in [+, -, *]\n    expression(X, operators)\nend\n# 842 ns","category":"page"},{"location":"","page":"Contents","title":"Contents","text":"Now, let's see the performance if we had hard-coded these expressions:","category":"page"},{"location":"","page":"Contents","title":"Contents","text":"f(X) = X[1, :] .* cos.(X[2, :] .- 3.2)\n@btime f(X)\n# 708 ns","category":"page"},{"location":"","page":"Contents","title":"Contents","text":"So, our dynamic expression evaluation is about the same (or even a bit faster) as evaluating a basic hard-coded expression! Let's see if we can optimize the speed of the hard-coded version:","category":"page"},{"location":"","page":"Contents","title":"Contents","text":"f_optimized(X) = begin\n    y = Vector{Float64}(undef, 100)\n    @inbounds @simd for i=1:100\n        y[i] = X[1, i] * cos(X[2, i] - 3.2)\n    end\n    y\nend\n@btime f_optimized(X)\n# 526 ns","category":"page"},{"location":"","page":"Contents","title":"Contents","text":"The DynamicExpressions.jl version is only 25% slower than one which has been optimized by hand into a single SIMD kernel! Not bad at all.","category":"page"},{"location":"","page":"Contents","title":"Contents","text":"More importantly: we can change expression throughout runtime, and expect the same performance. This makes this data structure ideal for symbolic regression and other evaluation-based searches over expression trees.","category":"page"},{"location":"#Derivatives","page":"Contents","title":"Derivatives","text":"","category":"section"},{"location":"","page":"Contents","title":"Contents","text":"We can also compute gradients with the same speed:","category":"page"},{"location":"","page":"Contents","title":"Contents","text":"using Zygote  # trigger extension\n\noperators = OperatorEnum(;\n    binary_operators=[+, -, *],\n    unary_operators=[cos],\n)\nx1 = Node(; feature=1)\nx2 = Node(; feature=2)\nexpression = x1 * cos(x2 - 3.2)","category":"page"},{"location":"","page":"Contents","title":"Contents","text":"We can take the gradient with respect to inputs with simply the ' character:","category":"page"},{"location":"","page":"Contents","title":"Contents","text":"grad = expression'(X, operators)","category":"page"},{"location":"","page":"Contents","title":"Contents","text":"This is quite fast:","category":"page"},{"location":"","page":"Contents","title":"Contents","text":"@btime expression'(X, operators)\n# 2894 ns","category":"page"},{"location":"","page":"Contents","title":"Contents","text":"and again, we can change this expression at runtime, without loss in performance!","category":"page"},{"location":"","page":"Contents","title":"Contents","text":"@btime begin\n    expression.op = rand(1:3)\n    expression'(X, operators)\nend\n# 3198 ns","category":"page"},{"location":"","page":"Contents","title":"Contents","text":"Internally, this is calling the eval_grad_tree_array function, which performs forward-mode automatic differentiation on the expression tree with Zygote-compiled kernels. We can also compute the derivative with respect to constants:","category":"page"},{"location":"","page":"Contents","title":"Contents","text":"result, grad, did_finish = eval_grad_tree_array(expression, X, operators; variable=false)","category":"page"},{"location":"","page":"Contents","title":"Contents","text":"or with respect to variables, and only in a single direction:","category":"page"},{"location":"","page":"Contents","title":"Contents","text":"feature = 2\nresult, grad, did_finish = eval_diff_tree_array(expression, X, operators, feature)","category":"page"},{"location":"#Generic-types","page":"Contents","title":"Generic types","text":"","category":"section"},{"location":"","page":"Contents","title":"Contents","text":"Does this work for only scalar operators on real numbers, or will it work for MyCrazyType?","category":"page"},{"location":"","page":"Contents","title":"Contents","text":"I'm so glad you asked. DynamicExpressions.jl actually will work for arbitrary types! However, to work on operators other than real scalars, you need to use the GenericOperatorEnum <: AbstractOperatorEnum instead of the normal OperatorEnum. Let's try it with strings!","category":"page"},{"location":"","page":"Contents","title":"Contents","text":"x1 = Node(String; feature=1) ","category":"page"},{"location":"","page":"Contents","title":"Contents","text":"This node, will be used to index input data (whatever it may be) with either data[feature] (1D abstract arrays) or selectdim(data, 1, feature) (ND abstract arrays). Let's now define some operators to use:","category":"page"},{"location":"","page":"Contents","title":"Contents","text":"my_string_func(x::String) = \"ello $x\"\n\noperators = GenericOperatorEnum(;\n    binary_operators=[*],\n    unary_operators=[my_string_func]\n)","category":"page"},{"location":"","page":"Contents","title":"Contents","text":"Now, let's extend our operators to work with the expression types used by DynamicExpressions.jl:","category":"page"},{"location":"","page":"Contents","title":"Contents","text":"@extend_operators operators","category":"page"},{"location":"","page":"Contents","title":"Contents","text":"Now, let's create an expression:","category":"page"},{"location":"","page":"Contents","title":"Contents","text":"tree = \"H\" * my_string_func(x1)\n# ^ `(H * my_string_func(x1))`\n\ntree([\"World!\", \"Me?\"], operators)\n# Hello World!","category":"page"},{"location":"","page":"Contents","title":"Contents","text":"So indeed it works for arbitrary types. It is a bit slower due to the potential for type instability, but it's not too bad:","category":"page"},{"location":"","page":"Contents","title":"Contents","text":"@btime tree([\"Hello\", \"Me?\"], operators)\n# 1738 ns","category":"page"},{"location":"#Tensors","page":"Contents","title":"Tensors","text":"","category":"section"},{"location":"","page":"Contents","title":"Contents","text":"Does this work for tensors, or even unions of scalars and tensors?","category":"page"},{"location":"","page":"Contents","title":"Contents","text":"Also yes! Let's see:","category":"page"},{"location":"","page":"Contents","title":"Contents","text":"using DynamicExpressions\n\nT = Union{Float64,Vector{Float64}}\n\nc1 = Node(T; val=0.0)  # Scalar constant\nc2 = Node(T; val=[1.0, 2.0, 3.0])  # Vector constant\nx1 = Node(T; feature=1)\n\n# Some operators on tensors (multiple dispatch can be used for different behavior!)\nvec_add(x, y) = x .+ y\nvec_square(x) = x .* x\n\n# Set up an operator enum:\noperators = GenericOperatorEnum(;binary_operators=[vec_add], unary_operators=[vec_square])\n@extend_operators operators\n\n# Construct the expression:\ntree = vec_add(vec_add(vec_square(x1), c2), c1)\n\nX = [[-1.0, 5.2, 0.1], [0.0, 0.0, 0.0]]\n\n# Evaluate!\ntree(X, operators)  # [2.0, 29.04, 3.01]","category":"page"},{"location":"","page":"Contents","title":"Contents","text":"Note that if an operator is not defined for the particular input, nothing will be returned instead.","category":"page"},{"location":"","page":"Contents","title":"Contents","text":"This is all still pretty fast, too:","category":"page"},{"location":"","page":"Contents","title":"Contents","text":"@btime tree(X, operators)\n# 2,949 ns\n@btime eval(:(vec_add(vec_add(vec_square(X[1]), [1.0, 2.0, 3.0]), 0.0)))\n# 115,000 ns","category":"page"},{"location":"#Contents","page":"Contents","title":"Contents","text":"","category":"section"},{"location":"","page":"Contents","title":"Contents","text":"Pages = [\"utils.md\", \"types.md\", \"eval.md\"]","category":"page"},{"location":"utils/#Node-utilities","page":"Node utilities","title":"Node utilities","text":"","category":"section"},{"location":"utils/#Base","page":"Node utilities","title":"Base","text":"","category":"section"},{"location":"utils/","page":"Node utilities","title":"Node utilities","text":"Various functions in Base are overloaded to treat an AbstractNode as a collection of its nodes.","category":"page"},{"location":"utils/","page":"Node utilities","title":"Node utilities","text":"copy(tree::AbstractExpressionNode; break_sharing::Val=Val(false))\ncollect(tree::AbstractNode; break_sharing::Val=Val(false))\nfilter(f::Function, tree::AbstractNode; break_sharing::Val=Val(false))\ncount(f::Function, tree::AbstractNode; init=0, break_sharing::Val=Val(false))\nforeach(f::Function, tree::AbstractNode; break_sharing::Val=Val(false))\nsum(f::F, tree::AbstractNode; init=0, return_type=Undefined, f_on_shared=_default_shared_aggregation, break_sharing::Val=Val(false)) where {F<:Function}\nmapreduce(f::F, op::G, tree::AbstractNode; return_type, f_on_shared, break_sharing) where {F<:Function,G<:Function}\nany(f::F, tree::AbstractNode) where {F<:Function}\nall(f::F, tree::AbstractNode) where {F<:Function}\nmap(f::F, tree::AbstractNode, result_type::Type{RT}=Nothing; break_sharing::Val=Val(false)) where {F<:Function,RT}\nconvert(::Type{<:AbstractExpressionNode{T1}}, n::AbstractExpressionNode{T2}) where {T1,T2}\nhash(tree::AbstractExpressionNode{T}, h::UInt; break_sharing::Val=Val(false)) where {T}","category":"page"},{"location":"utils/#Base.copy-Tuple{AbstractExpressionNode}","page":"Node utilities","title":"Base.copy","text":"copy(tree::AbstractExpressionNode; break_sharing::Val=Val(false))\n\nCopy a node, recursively copying all children nodes. This is more efficient than the built-in copy.\n\nIf break_sharing is set to Val(true), sharing in a tree will be ignored.\n\n\n\n\n\n","category":"method"},{"location":"utils/#Base.collect-Tuple{AbstractNode}","page":"Node utilities","title":"Base.collect","text":"collect(tree::AbstractNode; break_sharing::Val=Val(false))\n\nCollect all nodes in a tree into a flat array in depth-first order.\n\n\n\n\n\n","category":"method"},{"location":"utils/#Base.filter-Tuple{Function, AbstractNode}","page":"Node utilities","title":"Base.filter","text":"filter(f::Function, tree::AbstractNode; break_sharing::Val=Val(false))\n\nFilter nodes of a tree, returning a flat array of the nodes for which the function returns true.\n\n\n\n\n\n","category":"method"},{"location":"utils/#Base.count-Tuple{Function, AbstractNode}","page":"Node utilities","title":"Base.count","text":"count(f::F, tree::AbstractNode; init=0, break_sharing::Val=Val(false)) where {F<:Function}\n\nCount the number of nodes in a tree for which the function returns true.\n\n\n\n\n\n","category":"method"},{"location":"utils/#Base.foreach-Tuple{Function, AbstractNode}","page":"Node utilities","title":"Base.foreach","text":"foreach(f::Function, tree::AbstractNode; break_sharing::Val=Val(false))\n\nApply a function to each node in a tree without returning the results.\n\n\n\n\n\n","category":"method"},{"location":"utils/#Base.sum-Union{Tuple{F}, Tuple{F, AbstractNode}} where F<:Function","page":"Node utilities","title":"Base.sum","text":"sum(f::Function, tree::AbstractNode; init=0, return_type=Undefined, f_on_shared=_default_shared_aggregation, break_sharing::Val=Val(false)) where {F<:Function}\n\nSum the results of a function over a tree. For graphs with shared nodes such as GraphNode, the function f_on_shared is called on the result of each shared node. This is used to avoid double-counting shared nodes (default behavior).\n\n\n\n\n\n","category":"method"},{"location":"utils/#Base.mapreduce-Union{Tuple{G}, Tuple{F}, Tuple{F, G, AbstractNode}} where {F<:Function, G<:Function}","page":"Node utilities","title":"Base.mapreduce","text":"mapreduce(f::Function, op::Function, tree::AbstractNode; return_type, f_on_shared, break_sharing)\n\nMap a function over a tree and aggregate the result using an operator op.\n\n\n\n\n\n","category":"method"},{"location":"utils/#Base.any-Union{Tuple{F}, Tuple{F, AbstractNode}} where F<:Function","page":"Node utilities","title":"Base.any","text":"any(f::Function, tree::AbstractNode)\n\nReduce a flag function over a tree, returning true if the function returns true for any node. By using this instead of tree_mapreduce, we can take advantage of early exits.\n\n\n\n\n\n","category":"method"},{"location":"utils/#Base.all-Union{Tuple{F}, Tuple{F, AbstractNode}} where F<:Function","page":"Node utilities","title":"Base.all","text":"all(f::Function, tree::AbstractNode)\n\nReduce a flag function over a tree, returning true if the function returns true for all nodes, false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"utils/#Base.map-Union{Tuple{RT}, Tuple{F}, Tuple{F, AbstractNode}, Tuple{F, AbstractNode, Type{RT}}} where {F<:Function, RT}","page":"Node utilities","title":"Base.map","text":"map(f::F, tree::AbstractNode, result_type::Type{RT}=Nothing; break_sharing::Val=Val(false)) where {F<:Function,RT}\n\nMap a function over a tree and return a flat array of the results in depth-first order. Pre-specifying the result_type of the function can be used to avoid extra allocations.\n\n\n\n\n\n","category":"method"},{"location":"utils/#Base.convert-Union{Tuple{T2}, Tuple{T1}, Tuple{Type{<:AbstractExpressionNode{T1}}, AbstractExpressionNode{T2}}} where {T1, T2}","page":"Node utilities","title":"Base.convert","text":"convert(::Type{<:AbstractExpressionNode{T1}}, n::AbstractExpressionNode{T2}) where {T1,T2}\n\nConvert a AbstractExpressionNode{T2} to a AbstractExpressionNode{T1}. This will recursively convert all children nodes to AbstractExpressionNode{T1}, using convert(T1, tree.val) at constant nodes.\n\nArguments\n\n::Type{AbstractExpressionNode{T1}}: Type to convert to.\ntree::AbstractExpressionNode{T2}: AbstractExpressionNode to convert.\n\n\n\n\n\n","category":"method"},{"location":"utils/#Base.hash-Union{Tuple{T}, Tuple{AbstractExpressionNode{T}, UInt64}} where T","page":"Node utilities","title":"Base.hash","text":"hash(tree::AbstractExpressionNode{T}[, h::UInt]; break_sharing::Val=Val(false)) where {T}\n\nCompute a hash of a tree. This will compute a hash differently if nodes are shared in a tree. This is ignored if break_sharing is set to Val(true).\n\n\n\n\n\n","category":"method"},{"location":"utils/#Printing","page":"Node utilities","title":"Printing","text":"","category":"section"},{"location":"utils/","page":"Node utilities","title":"Node utilities","text":"Trees are printed using the string_tree function, which is very configurable:","category":"page"},{"location":"utils/","page":"Node utilities","title":"Node utilities","text":"string_tree(tree::Node, operators::AbstractOperatorEnum)","category":"page"},{"location":"utils/#DynamicExpressions.EquationModule.string_tree-Tuple{Node, AbstractOperatorEnum}","page":"Node utilities","title":"DynamicExpressions.EquationModule.string_tree","text":"string_tree(\n    tree::AbstractExpressionNode{T},\n    operators::Union{AbstractOperatorEnum,Nothing}=nothing;\n    f_variable::F1=string_variable,\n    f_constant::F2=string_constant,\n    variable_names::Union{Array{String,1},Nothing}=nothing,\n    # Deprecated\n    varMap=nothing,\n)::String where {T,F1<:Function,F2<:Function}\n\nConvert an equation to a string.\n\nArguments\n\ntree: the tree to convert to a string\noperators: the operators used to define the tree\n\nKeyword Arguments\n\nf_variable: (optional) function to convert a variable to a string, with arguments (feature::UInt8, variable_names).\nf_constant: (optional) function to convert a constant to a string, with arguments (val,)\nvariable_names::Union{Array{String, 1}, Nothing}=nothing: (optional) what variables to print for each feature.\n\n\n\n\n\n","category":"method"},{"location":"utils/","page":"Node utilities","title":"Node utilities","text":"The standard show and print methods will use the most recently-created OperatorEnum in a string_tree.","category":"page"},{"location":"utils/#Sampling","page":"Node utilities","title":"Sampling","text":"","category":"section"},{"location":"utils/","page":"Node utilities","title":"Node utilities","text":"There are also methods for random sampling of nodes:","category":"page"},{"location":"utils/","page":"Node utilities","title":"Node utilities","text":"NodeSampler\nrand(rng::AbstractRNG, tree::AbstractNode)\nrand(rng::AbstractRNG, sampler::NodeSampler{N,F,Nothing}) where {N,F}","category":"page"},{"location":"utils/#DynamicExpressions.RandomModule.NodeSampler","page":"Node utilities","title":"DynamicExpressions.RandomModule.NodeSampler","text":"NodeSampler(; tree, filter::Function=Returns(true), weighting::Union{Nothing,Function}=nothing, break_sharing::Val=Val(false))\n\nDefines a sampler of nodes in a tree.\n\nArguments\n\ntree: The tree to sample nodes from. For a regular Node, nodes are sampled uniformly. For a GraphNode, nodes are also sampled uniformly (e.g., in sin(x) + {x}, the x has equal probability of being sampled from the sin or the + node, because it is shared), unless break_sharing is set to Val(true).\nfilter::Function: A function that takes a node and returns a boolean indicating whether the node should be sampled. Defaults to Returns(true).\nweighting::Union{Nothing,Function}: A function that takes a node and returns a weight for the node, if it passes the filter, proportional to the probability of sampling the node. If nothing, all nodes are sampled uniformly.\nbreak_sharing::Val: If Val(true), the sampler will break sharing in the tree, and sample nodes uniformly from the tree.\n\n\n\n\n\n","category":"type"},{"location":"utils/#Base.rand-Tuple{AbstractRNG, AbstractNode}","page":"Node utilities","title":"Base.rand","text":"rand(rng::AbstractRNG, tree::AbstractNode)\n\nSample a node from a tree according to the default sampler NodeSampler(; tree).\n\n\n\n\n\n","category":"method"},{"location":"utils/#Base.rand-Union{Tuple{F}, Tuple{N}, Tuple{AbstractRNG, NodeSampler{N, F, Nothing}}} where {N, F}","page":"Node utilities","title":"Base.rand","text":"rand(rng::AbstractRNG, sampler::NodeSampler)\n\nSample a node from a tree according to the sampler sampler.\n\n\n\n\n\n","category":"method"},{"location":"utils/#Internal-utilities","page":"Node utilities","title":"Internal utilities","text":"","category":"section"},{"location":"utils/","page":"Node utilities","title":"Node utilities","text":"Almost all node utilities are crafted using the tree_mapreduce function, which evaluates a mapreduce over a tree-like (or graph-like) structure:","category":"page"},{"location":"utils/","page":"Node utilities","title":"Node utilities","text":"tree_mapreduce","category":"page"},{"location":"utils/#DynamicExpressions.EquationModule.tree_mapreduce","page":"Node utilities","title":"DynamicExpressions.EquationModule.tree_mapreduce","text":"tree_mapreduce(\n    f::Function,\n    [f_branch::Function,]\n    op::Function,\n    tree::AbstractNode,\n    f_on_shared::Function=(result, is_shared) -> result,\n    break_sharing::Val=Val(false),\n)\n\nMap a function over a tree and aggregate the result using an operator op. op should be defined with inputs (parent, child...) -> so that it can aggregate both unary and binary operators. op will not be called for leafs of the tree. This differs from a normal mapreduce in that it allows different treatment for parent nodes than children nodes. If this is not necessary, you may use the regular mapreduce instead. The argument break_sharing can be used to break connections in a GraphNode.\n\nYou can also provide separate functions for leaf (variable/constant) nodes and branch (operator) nodes.\n\nExamples\n\njulia> operators = OperatorEnum(; binary_operators=[+, *]);\n\njulia> tree = Node(; feature=1) + Node(; feature=2) * 3.2;\n\njulia> tree_mapreduce(t -> 1, +, tree)  # count nodes. (regular mapreduce also works)\n5\n\njulia> tree_mapreduce(t -> 1, (p, c...) -> p + max(c...), tree)  # compute depth. regular mapreduce would fail!\n5\n\njulia> tree_mapreduce(vcat, tree) do t\n    t.degree == 2 ? [t.op] : UInt8[]\nend  # Get list of binary operators used. (regular mapreduce also works)\n2-element Vector{UInt8}:\n 1\n 2\n\njulia> tree_mapreduce(vcat, tree) do t\n    (t.degree == 0 && t.constant) ? [t.val] : Float64[]\nend  # Get list of constants. (regular mapreduce also works)\n1-element Vector{Float64}:\n 3.2\n\n\n\n\n\n","category":"function"},{"location":"utils/","page":"Node utilities","title":"Node utilities","text":"Various other utility functions include the following:","category":"page"},{"location":"utils/","page":"Node utilities","title":"Node utilities","text":"filter_map\nfilter_map!","category":"page"},{"location":"utils/#DynamicExpressions.EquationModule.filter_map","page":"Node utilities","title":"DynamicExpressions.EquationModule.filter_map","text":"filter_map(filter_fnc::Function, map_fnc::Function, tree::AbstractNode, result_type::Type, break_sharing::Val=Val(false))\n\nA faster equivalent to map(map_fnc, filter(filter_fnc, tree)) that avoids the intermediate allocation. However, using this requires specifying the result_type of map_fnc so the resultant array can be preallocated.\n\n\n\n\n\n","category":"function"},{"location":"utils/#DynamicExpressions.EquationModule.filter_map!","page":"Node utilities","title":"DynamicExpressions.EquationModule.filter_map!","text":"filter_map!(filter_fnc::Function, map_fnc::Function, stack::Vector{GT}, tree::AbstractNode)\n\nEquivalent to filter_map, but stores the results in a preallocated array.\n\n\n\n\n\n","category":"function"},{"location":"types/#Types","page":"Types","title":"Types","text":"","category":"section"},{"location":"types/#Operator-Enum","page":"Types","title":"Operator Enum","text":"","category":"section"},{"location":"types/","page":"Types","title":"Types","text":"All equations are represented as a tree of operators. Each node in this tree specifies its operator with an integer - which indexes an enum of operators. This enum is defined as follows:","category":"page"},{"location":"types/","page":"Types","title":"Types","text":"OperatorEnum","category":"page"},{"location":"types/#DynamicExpressions.OperatorEnumModule.OperatorEnum","page":"Types","title":"DynamicExpressions.OperatorEnumModule.OperatorEnum","text":"OperatorEnum\n\nDefines an enum over operators, along with their derivatives.\n\nFields\n\nbinops: A tuple of binary operators. Scalar input type.\nunaops: A tuple of unary operators. Scalar input type.\n\n\n\n\n\n","category":"type"},{"location":"types/","page":"Types","title":"Types","text":"Construct this operator specification as follows:","category":"page"},{"location":"types/","page":"Types","title":"Types","text":"OperatorEnum(; binary_operators=[], unary_operators=[], define_helper_functions::Bool=true)","category":"page"},{"location":"types/#DynamicExpressions.OperatorEnumModule.OperatorEnum-Tuple{}","page":"Types","title":"DynamicExpressions.OperatorEnumModule.OperatorEnum","text":"OperatorEnum(; binary_operators=[], unary_operators=[],\n               define_helper_functions::Bool=true,\n               empty_old_operators::Bool=true)\n\nConstruct an OperatorEnum object, defining the possible expressions. This will also redefine operators for AbstractExpressionNode types, as well as show, print, and (::AbstractExpressionNode)(X). It will automatically compute derivatives with Zygote.jl.\n\nArguments\n\nbinary_operators::Vector{Function}: A vector of functions, each of which is a binary operator.\nunary_operators::Vector{Function}: A vector of functions, each of which is a unary operator.\ndefine_helper_functions::Bool=true: Whether to define helper functions for creating  and evaluating node types. Turn this off when doing precompilation. Note that these  are not needed for the package to work; they are purely for convenience.\nempty_old_operators::Bool=true: Whether to clear the old operators.\n\n\n\n\n\n","category":"method"},{"location":"types/","page":"Types","title":"Types","text":"This is just for scalar operators. However, you can use the following for more general operators:","category":"page"},{"location":"types/","page":"Types","title":"Types","text":"GenericOperatorEnum(; binary_operators=[], unary_operators=[], define_helper_functions::Bool=true)","category":"page"},{"location":"types/#DynamicExpressions.OperatorEnumModule.GenericOperatorEnum-Tuple{}","page":"Types","title":"DynamicExpressions.OperatorEnumModule.GenericOperatorEnum","text":"GenericOperatorEnum(; binary_operators=[], unary_operators=[],\n                      define_helper_functions::Bool=true, empty_old_operators::Bool=true)\n\nConstruct a GenericOperatorEnum object, defining possible expressions. Unlike OperatorEnum, this enum one will work arbitrary operators and data types. This will also redefine operators for AbstractExpressionNode types, as well as show, print, and (::AbstractExpressionNode)(X).\n\nArguments\n\nbinary_operators::Vector{Function}: A vector of functions, each of which is a binary operator.\nunary_operators::Vector{Function}: A vector of functions, each of which is a unary operator.\ndefine_helper_functions::Bool=true: Whether to define helper functions for creating  and evaluating node types. Turn this off when doing precompilation. Note that these  are not needed for the package to work; they are purely for convenience.\nempty_old_operators::Bool=true: Whether to clear the old operators.\n\n\n\n\n\n","category":"method"},{"location":"types/","page":"Types","title":"Types","text":"By default, these operators will define helper functions for constructing trees, so that you can write Node(;feature=1) + Node(;feature=2) instead of Node(1, Node(;feature=1), Node(;feature=2)) (assuming + is the first operator). You can turn this off with define_helper_functions=false.","category":"page"},{"location":"types/","page":"Types","title":"Types","text":"For other operators not found in Base, including user-defined functions, you may use the @extend_operators macro:","category":"page"},{"location":"types/","page":"Types","title":"Types","text":"@extend_operators operators","category":"page"},{"location":"types/#DynamicExpressions.OperatorEnumConstructionModule.@extend_operators-Tuple{Any}","page":"Types","title":"DynamicExpressions.OperatorEnumConstructionModule.@extend_operators","text":"@extend_operators operators [kws...]\n\nExtends all operators defined in this operator enum to work on the Node type. While by default this is already done for operators defined in Base when you create an enum and pass define_helper_functions=true, this does not apply to the user-defined operators. Thus, to do so, you must apply this macro to the operator enum in the same module you have the operators defined.\n\n\n\n\n\n","category":"macro"},{"location":"types/","page":"Types","title":"Types","text":"This will extend the operators you have passed to work with Node types, so that it is easier to construct expression trees.","category":"page"},{"location":"types/","page":"Types","title":"Types","text":"Note that you are free to use the Node constructors directly. This is a more robust approach, and should be used when creating libraries which use DynamicExpressions.jl.","category":"page"},{"location":"types/#Equations","page":"Types","title":"Equations","text":"","category":"section"},{"location":"types/","page":"Types","title":"Types","text":"Equations are specified as binary trees with the Node type, defined as follows:","category":"page"},{"location":"types/","page":"Types","title":"Types","text":"Node","category":"page"},{"location":"types/#DynamicExpressions.EquationModule.Node","page":"Types","title":"DynamicExpressions.EquationModule.Node","text":"Node{T} <: AbstractExpressionNode{T}\n\nNode defines a symbolic expression stored in a binary tree. A single Node instance is one \"node\" of this tree, and has references to its children. By tracing through the children nodes, you can evaluate or print a given expression.\n\nFields\n\ndegree::UInt8: Degree of the node. 0 for constants, 1 for   unary operators, 2 for binary operators.\nconstant::Bool: Whether the node is a constant.\nval::T: Value of the node. If degree==0, and constant==true,   this is the value of the constant. It has a type specified by the   overall type of the Node (e.g., Float64).\nfeature::UInt16: Index of the feature to use in the   case of a feature node. Only used if degree==0 and constant==false.    Only defined if degree == 0 && constant == false.\nop::UInt8: If degree==1, this is the index of the operator   in operators.unaops. If degree==2, this is the index of the   operator in operators.binops. In other words, this is an enum   of the operators, and is dependent on the specific OperatorEnum   object. Only defined if degree >= 1\nl::Node{T}: Left child of the node. Only defined if degree >= 1.   Same type as the parent node.\nr::Node{T}: Right child of the node. Only defined if degree == 2.   Same type as the parent node. This is to be passed as the right   argument to the binary operator.\n\nConstructors\n\nLeafs\n\nNode(; val=nothing, feature::Union{Integer,Nothing}=nothing)\nNode{T}(; val=nothing, feature::Union{Integer,Nothing}=nothing) where {T}\n\nCreate a leaf node: either a constant, or a variable.\n\n::Type{T}, optionally specify the type of the   node, if not already given by the type of   val.\nval, if you are specifying a constant, pass   the value of the constant here.\nfeature::Integer, if you are specifying a variable,   pass the index of the variable here.\n\nYou can also create a leaf node from variable names:\n\nNode(; var_string::String, variable_names::Array{String,1})\nNode{T}(; var_string::String, variable_names::Array{String,1}) where {T}\n\nUnary operator\n\nNode(op::Integer, l::Node)\n\nApply unary operator op (enumerating over the order given in OperatorEnum) to Node l.\n\nBinary operator\n\nNode(op::Integer, l::Node, r::Node)\n\nApply binary operator op (enumerating over the order given in OperatorEnum) to Nodes l and r.\n\n\n\n\n\n","category":"type"},{"location":"types/","page":"Types","title":"Types","text":"When you create an Options object, the operators passed are also re-defined for Node types. This allows you use, e.g., t=Node(; feature=1) * 3f0 to create a tree, so long as * was specified as a binary operator.","category":"page"},{"location":"types/","page":"Types","title":"Types","text":"When using these node constructors, types will automatically be promoted. You can convert the type of a node using convert:","category":"page"},{"location":"types/","page":"Types","title":"Types","text":"convert(::Type{AbstractExpressionNode{T1}}, tree::AbstractExpressionNode{T2}) where {T1, T2}","category":"page"},{"location":"types/#Base.convert-Union{Tuple{T2}, Tuple{T1}, Tuple{Type{AbstractExpressionNode{T1}}, AbstractExpressionNode{T2}}} where {T1, T2}","page":"Types","title":"Base.convert","text":"convert(::Type{<:AbstractExpressionNode{T1}}, n::AbstractExpressionNode{T2}) where {T1,T2}\n\nConvert a AbstractExpressionNode{T2} to a AbstractExpressionNode{T1}. This will recursively convert all children nodes to AbstractExpressionNode{T1}, using convert(T1, tree.val) at constant nodes.\n\nArguments\n\n::Type{AbstractExpressionNode{T1}}: Type to convert to.\ntree::AbstractExpressionNode{T2}: AbstractExpressionNode to convert.\n\n\n\n\n\n","category":"method"},{"location":"types/","page":"Types","title":"Types","text":"You can set a tree (in-place) with set_node!:","category":"page"},{"location":"types/","page":"Types","title":"Types","text":"set_node!","category":"page"},{"location":"types/#DynamicExpressions.EquationModule.set_node!","page":"Types","title":"DynamicExpressions.EquationModule.set_node!","text":"set_node!(tree::AbstractExpressionNode{T}, new_tree::AbstractExpressionNode{T}) where {T}\n\nSet every field of tree equal to the corresponding field of new_tree.\n\n\n\n\n\n","category":"function"},{"location":"types/","page":"Types","title":"Types","text":"You can create a copy of a node with copy_node:","category":"page"},{"location":"types/","page":"Types","title":"Types","text":"copy_node","category":"page"},{"location":"types/#DynamicExpressions.EquationModule.copy_node","page":"Types","title":"DynamicExpressions.EquationModule.copy_node","text":"copy_node(tree::AbstractExpressionNode; break_sharing::Val=Val(false))\n\nCopy a node, recursively copying all children nodes. This is more efficient than the built-in copy.\n\nIf break_sharing is set to Val(true), sharing in a tree will be ignored.\n\n\n\n\n\n","category":"function"},{"location":"types/#Graph-Like-Equations","page":"Types","title":"Graph-Like Equations","text":"","category":"section"},{"location":"types/","page":"Types","title":"Types","text":"You can describe an equation as a graph rather than a tree by using the GraphNode type:","category":"page"},{"location":"types/","page":"Types","title":"Types","text":"GraphNode{T}","category":"page"},{"location":"types/#DynamicExpressions.EquationModule.GraphNode","page":"Types","title":"DynamicExpressions.EquationModule.GraphNode","text":"GraphNode{T} <: AbstractExpressionNode{T}\n\nExactly the same as Node{T}, but with the assumption that some nodes will be shared. All copies of this graph-like structure will be performed with this assumption, to preserve structure of the graph.\n\nExamples\n\njulia> operators = OperatorEnum(;\n           binary_operators=[+, -, *], unary_operators=[cos, sin]\n       );\n\njulia> x = GraphNode(feature=1)\nx1\n\njulia> y = sin(x) + x\nsin(x1) + {x1}\n\njulia> cos(y) * y\ncos(sin(x1) + {x1}) * {(sin(x1) + {x1})}\n\nNote how the {} indicates a node is shared, and this is the same node as seen earlier in the string.\n\nThis has the same constructors as Node{T}. Shared nodes are created simply by using the same node in multiple places when constructing or setting properties.\n\n\n\n\n\n","category":"type"},{"location":"types/","page":"Types","title":"Types","text":"This makes it so you can have multiple parents for a given node, and share parts of an expression. For example:","category":"page"},{"location":"types/","page":"Types","title":"Types","text":"julia> operators = OperatorEnum(;\n           binary_operators=[+, -, *], unary_operators=[cos, sin, exp]\n       );\n\njulia> x1, x2 = GraphNode(feature=1), GraphNode(feature=2)\n(x1, x2)\n\njulia> y = sin(x1) + 1.5\nsin(x1) + 1.5\n\njulia> z = exp(y) + y\nexp(sin(x1) + 1.5) + {(sin(x1) + 1.5)}","category":"page"},{"location":"types/","page":"Types","title":"Types","text":"Here, the curly braces {} indicate that the node is shared by another (or more) parent node.","category":"page"},{"location":"types/","page":"Types","title":"Types","text":"This means that we only need to change it once to have changes propagate across the expression:","category":"page"},{"location":"types/","page":"Types","title":"Types","text":"julia> y.r.val *= 0.9\n1.35\n\njulia> z\nexp(sin(x1) + 1.35) + {(sin(x1) + 1.35)}","category":"page"},{"location":"types/","page":"Types","title":"Types","text":"This also means there are fewer nodes to describe an expression:","category":"page"},{"location":"types/","page":"Types","title":"Types","text":"julia> length(z)\n6\n\njulia> length(convert(Node, z))\n10","category":"page"},{"location":"types/","page":"Types","title":"Types","text":"where we have converted the GraphNode to a Node type, which breaks shared connections into separate nodes.","category":"page"},{"location":"types/#Abstract-Types","page":"Types","title":"Abstract Types","text":"","category":"section"},{"location":"types/","page":"Types","title":"Types","text":"Both the Node and GraphNode types are subtypes of the abstract type:","category":"page"},{"location":"types/","page":"Types","title":"Types","text":"AbstractExpressionNode{T}","category":"page"},{"location":"types/#DynamicExpressions.EquationModule.AbstractExpressionNode","page":"Types","title":"DynamicExpressions.EquationModule.AbstractExpressionNode","text":"AbstractExpressionNode{T} <: AbstractNode\n\nAbstract type for nodes that represent an expression. Along with the fields required for AbstractNode, this additionally must have fields for:\n\nconstant::Bool: Whether the node is a constant.\nval::T: Value of the node. If degree==0, and constant==true,   this is the value of the constant. It has a type specified by the   overall type of the Node (e.g., Float64).\nfeature::UInt16: Index of the feature to use in the   case of a feature node. Only used if degree==0 and constant==false.    Only defined if degree == 0 && constant == false.\nop::UInt8: If degree==1, this is the index of the operator   in operators.unaops. If degree==2, this is the index of the   operator in operators.binops. In other words, this is an enum   of the operators, and is dependent on the specific OperatorEnum   object. Only defined if degree >= 1\n\n```\n\n\n\n\n\n","category":"type"},{"location":"types/","page":"Types","title":"Types","text":"which can be used to create additional expression-like types. The supertype of this abstract type is the AbstractNode type, which is more generic but does not have all of the same methods:","category":"page"},{"location":"types/","page":"Types","title":"Types","text":"AbstractNode{T}","category":"page"},{"location":"types/#DynamicExpressions.EquationModule.AbstractNode","page":"Types","title":"DynamicExpressions.EquationModule.AbstractNode","text":"AbstractNode\n\nAbstract type for binary trees. Must have the following fields:\n\ndegree::Integer: Degree of the node. Either 0, 1, or 2. If 1,   then l needs to be defined as the left child. If 2,   then r also needs to be defined as the right child.\nl::AbstractNode: Left child of the current node. Should only be   defined if degree >= 1; otherwise, leave it undefined (see the   the constructors of Node{T} for an example).   Don't use nothing to represent an undefined value   as it will incur a large performance penalty.\nr::AbstractNode: Right child of the current node. Should only   be defined if degree == 2.\n\n\n\n\n\n","category":"type"}]
}
