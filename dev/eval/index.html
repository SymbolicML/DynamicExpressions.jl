<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Evaluation · DynamicExpressions.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">DynamicExpressions.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Contents</a></li><li class="is-active"><a class="tocitem" href>Evaluation</a><ul class="internal"><li><a class="tocitem" href="#Derivatives"><span>Derivatives</span></a></li><li><a class="tocitem" href="#Printing"><span>Printing</span></a></li></ul></li><li><a class="tocitem" href="../types/">Types</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Evaluation</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Evaluation</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/SymbolicML/DynamicExpressions.jl/blob/master/docs/src/eval.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Evaluation"><a class="docs-heading-anchor" href="#Evaluation">Evaluation</a><a id="Evaluation-1"></a><a class="docs-heading-anchor-permalink" href="#Evaluation" title="Permalink"></a></h1><p>Given an expression tree specified with a <code>Node</code> type, you may evaluate the expression over an array of data with the following command:</p><article class="docstring"><header><a class="docstring-binding" id="DynamicExpressions.EvaluateEquationModule.eval_tree_array-Union{Tuple{T}, Tuple{Node{T}, AbstractMatrix{T}, OperatorEnum}} where T&lt;:Number" href="#DynamicExpressions.EvaluateEquationModule.eval_tree_array-Union{Tuple{T}, Tuple{Node{T}, AbstractMatrix{T}, OperatorEnum}} where T&lt;:Number"><code>DynamicExpressions.EvaluateEquationModule.eval_tree_array</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">eval_tree_array(tree::Node, cX::AbstractMatrix{T}, operators::OperatorEnum; turbo::Bool=false)</code></pre><p>Evaluate a binary tree (equation) over a given input data matrix. The operators contain all of the operators used. This function fuses doublets and triplets of operations for lower memory usage.</p><p>This function can be represented by the following pseudocode:</p><pre><code class="nohighlight hljs">function eval(current_node)
    if current_node is leaf
        return current_node.value
    elif current_node is degree 1
        return current_node.operator(eval(current_node.left_child))
    else
        return current_node.operator(eval(current_node.left_child), eval(current_node.right_child))</code></pre><p>The bulk of the code is for optimizations and pre-emptive NaN/Inf checks, which speed up evaluation significantly.</p><p><strong>Arguments</strong></p><ul><li><code>tree::Node</code>: The root node of the tree to evaluate.</li><li><code>cX::AbstractMatrix{T}</code>: The input data to evaluate the tree on.</li><li><code>operators::OperatorEnum</code>: The operators used in the tree.</li><li><code>turbo::Bool</code>: Use <code>LoopVectorization.@turbo</code> for faster evaluation.</li></ul><p><strong>Returns</strong></p><ul><li><code>(output, complete)::Tuple{AbstractVector{T}, Bool}</code>: the result,   which is a 1D array, as well as if the evaluation completed   successfully (true/false). A <code>false</code> complete means an infinity   or nan was encountered, and a large loss should be assigned   to the equation.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SymbolicML/DynamicExpressions.jl/blob/cd1fc0c66559608b96244285a3bc89e4f4e770ff/src/EvaluateEquation.jl#L25-L58">source</a></section></article><p>Assuming you are only using a single <code>OperatorEnum</code>, you can also use the following shorthand by using the expression as a function:</p><pre><code class="nohighlight hljs">    (tree::Node)(X::AbstractMatrix{T}, operators::OperatorEnum; turbo::Bool=false)

Evaluate a binary tree (equation) over a given data matrix. The
operators contain all of the operators used in the tree.

# Arguments
- `X::AbstractMatrix{T}`: The input data to evaluate the tree on.
- `operators::OperatorEnum`: The operators used in the tree.
- `turbo::Bool`: Use `LoopVectorization.@turbo` for faster evaluation.

# Returns
- `output::AbstractVector{T}`: the result, which is a 1D array.
    Any NaN, Inf, or other failure during the evaluation will result in the entire
    output array being set to NaN.</code></pre><p>For example,</p><pre><code class="language-julia hljs">using DynamicExpressions

operators = OperatorEnum(; binary_operators=[+, -, *], unary_operators=[cos])
tree = Node(; feature=1) * cos(Node(; feature=2) - 3.2)

tree([1 2 3; 4 5 6.], operators)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">3-element Vector{Float64}:
  0.6967067093471655
 -0.4544041893861738
 -2.8266670220059744</code></pre><p>This is possible because when you call <code>OperatorEnum</code>, it automatically re-defines <code>(::Node)(X)</code> to call the evaluation operation with the given <code>operators loaded. It also re-defines</code>print<code>,</code>show<code>, and the various operators, to work with the</code>Node` type.</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>The <code>Node</code> type does not know about which <code>OperatorEnum</code> you used to create it. Thus, if you define an expression with one <code>OperatorEnum</code>, and then try to evaluate it or print it with a different <code>OperatorEnum</code>, you will get undefined behavior!</p></div></div><p>You can also work with arbitrary types, by defining a <code>GenericOperatorEnum</code> instead. The notation is the same for <code>eval_tree_array</code>, though it will return <code>nothing</code> when it can&#39;t find a method, and not do any NaN checks:</p><article class="docstring"><header><a class="docstring-binding" id="DynamicExpressions.EvaluateEquationModule.eval_tree_array-Tuple{Node, AbstractMatrix, GenericOperatorEnum}" href="#DynamicExpressions.EvaluateEquationModule.eval_tree_array-Tuple{Node, AbstractMatrix, GenericOperatorEnum}"><code>DynamicExpressions.EvaluateEquationModule.eval_tree_array</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">eval_tree_array(tree::Node, cX::AbstractMatrix, operators::GenericOperatorEnum; throw_errors::Bool=true)</code></pre><p>Evaluate a generic binary tree (equation) over a given input data, whatever that input data may be. The <code>operators</code> enum contains all of the operators used. Unlike <code>eval_tree_array</code> with the normal <code>OperatorEnum</code>, the array <code>cX</code> is sliced only along the first dimension. i.e., if <code>cX</code> is a vector, then the output of a feature node will be a scalar. If <code>cX</code> is a 3D tensor, then the output of a feature node will be a 2D tensor. Note also that <code>tree.feature</code> will index along the first axis of <code>cX</code>.</p><p>However, there is no requirement about input and output types in general. You may set up your tree such that some operator nodes work on tensors, while other operator nodes work on scalars. <code>eval_tree_array</code> will simply return <code>nothing</code> if a given operator is not defined for the given input type.</p><p>This function can be represented by the following pseudocode:</p><pre><code class="nohighlight hljs">function eval(current_node)
    if current_node is leaf
        return current_node.value
    elif current_node is degree 1
        return current_node.operator(eval(current_node.left_child))
    else
        return current_node.operator(eval(current_node.left_child), eval(current_node.right_child))</code></pre><p><strong>Arguments</strong></p><ul><li><code>tree::Node</code>: The root node of the tree to evaluate.</li><li><code>cX::AbstractArray</code>: The input data to evaluate the tree on.</li><li><code>operators::GenericOperatorEnum</code>: The operators used in the tree.</li><li><code>throw_errors::Bool=true</code>: Whether to throw errors   if they occur during evaluation. Otherwise,   MethodErrors will be caught before they happen and    evaluation will return <code>nothing</code>,   rather than throwing an error. This is useful in cases   where you are unsure if a particular tree is valid or not,   and would prefer to work with <code>nothing</code> as an output.</li></ul><p><strong>Returns</strong></p><ul><li><code>(output, complete)::Tuple{Any, Bool}</code>: the result,   as well as if the evaluation completed successfully (true/false).   If evaluation failed, <code>nothing</code> will be returned for the first argument.   A <code>false</code> complete means an operator was called on input types   that it was not defined for.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SymbolicML/DynamicExpressions.jl/blob/cd1fc0c66559608b96244285a3bc89e4f4e770ff/src/EvaluateEquation.jl#L414-L461">source</a></section></article><p>Likewise for the shorthand notation:</p><pre><code class="nohighlight hljs">    (tree::Node)(X::AbstractMatrix, operators::GenericOperatorEnum; throw_errors::Bool=true)

# Arguments
- `X::AbstractArray`: The input data to evaluate the tree on.
- `operators::GenericOperatorEnum`: The operators used in the tree.
- `throw_errors::Bool=true`: Whether to throw errors
    if they occur during evaluation. Otherwise,
    MethodErrors will be caught before they happen and 
    evaluation will return `nothing`,
    rather than throwing an error. This is useful in cases
    where you are unsure if a particular tree is valid or not,
    and would prefer to work with `nothing` as an output.

# Returns
- `output`: the result of the evaluation.
    If evaluation failed, `nothing` will be returned for the first argument.
    A `false` complete means an operator was called on input types
    that it was not defined for. You can change this behavior by
    setting `throw_errors=false`.</code></pre><h2 id="Derivatives"><a class="docs-heading-anchor" href="#Derivatives">Derivatives</a><a id="Derivatives-1"></a><a class="docs-heading-anchor-permalink" href="#Derivatives" title="Permalink"></a></h2><p><code>DynamicExpressions.jl</code> can efficiently compute first-order derivatives of expressions with respect to variables or constants. This is done using either <code>eval_diff_tree_array</code>, to compute derivative with respect to a single variable, or with <code>eval_grad_tree_array</code>, to compute the gradient with respect all variables (or, all constants). Both use forward-mode automatic, but use <code>Zygote.jl</code> to compute derivatives of each operator, so this is very efficient.</p><article class="docstring"><header><a class="docstring-binding" id="DynamicExpressions.EvaluateEquationDerivativeModule.eval_diff_tree_array-Union{Tuple{T}, Tuple{Node{T}, AbstractMatrix{T}, OperatorEnum, Integer}} where T&lt;:Number" href="#DynamicExpressions.EvaluateEquationDerivativeModule.eval_diff_tree_array-Union{Tuple{T}, Tuple{Node{T}, AbstractMatrix{T}, OperatorEnum, Integer}} where T&lt;:Number"><code>DynamicExpressions.EvaluateEquationDerivativeModule.eval_diff_tree_array</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">eval_diff_tree_array(tree::Node{T}, cX::AbstractMatrix{T}, operators::OperatorEnum, direction::Integer; turbo::Bool=false)</code></pre><p>Compute the forward derivative of an expression, using a similar structure and optimization to eval<em>tree</em>array. <code>direction</code> is the index of a particular variable in the expression. e.g., <code>direction=1</code> would indicate derivative with respect to <code>x1</code>.</p><p><strong>Arguments</strong></p><ul><li><code>tree::Node</code>: The expression tree to evaluate.</li><li><code>cX::AbstractMatrix{T}</code>: The data matrix, with each column being a data point.</li><li><code>operators::OperatorEnum</code>: The operators used to create the <code>tree</code>. Note that <code>operators.enable_autodiff</code>   must be <code>true</code>. This is needed to create the derivative operations.</li><li><code>direction::Integer</code>: The index of the variable to take the derivative with respect to.</li><li><code>turbo::Bool</code>: Use <code>LoopVectorization.@turbo</code> for faster evaluation.</li></ul><p><strong>Returns</strong></p><ul><li><code>(evaluation, derivative, complete)::Tuple{AbstractVector{T}, AbstractVector{T}, Bool}</code>: the normal evaluation,   the derivative, and whether the evaluation completed as normal (or encountered a nan or inf).</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SymbolicML/DynamicExpressions.jl/blob/cd1fc0c66559608b96244285a3bc89e4f4e770ff/src/EvaluateEquationDerivative.jl#L20-L41">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicExpressions.EvaluateEquationDerivativeModule.eval_grad_tree_array-Union{Tuple{T}, Tuple{Node{T}, AbstractMatrix{T}, OperatorEnum}} where T&lt;:Number" href="#DynamicExpressions.EvaluateEquationDerivativeModule.eval_grad_tree_array-Union{Tuple{T}, Tuple{Node{T}, AbstractMatrix{T}, OperatorEnum}} where T&lt;:Number"><code>DynamicExpressions.EvaluateEquationDerivativeModule.eval_grad_tree_array</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">eval_grad_tree_array(tree::Node{T}, cX::AbstractMatrix{T}, operators::OperatorEnum; variable::Bool=false, turbo::Bool=false)</code></pre><p>Compute the forward-mode derivative of an expression, using a similar structure and optimization to eval<em>tree</em>array. <code>variable</code> specifies whether we should take derivatives with respect to features (i.e., cX), or with respect to every constant in the expression.</p><p><strong>Arguments</strong></p><ul><li><code>tree::Node{T}</code>: The expression tree to evaluate.</li><li><code>cX::AbstractMatrix{T}</code>: The data matrix, with each column being a data point.</li><li><code>operators::OperatorEnum</code>: The operators used to create the <code>tree</code>. Note that <code>operators.enable_autodiff</code>   must be <code>true</code>. This is needed to create the derivative operations.</li><li><code>variable::Bool</code>: Whether to take derivatives with respect to features (i.e., <code>cX</code> - with <code>variable=true</code>),   or with respect to every constant in the expression (<code>variable=false</code>).</li><li><code>turbo::Bool</code>: Use <code>LoopVectorization.@turbo</code> for faster evaluation.</li></ul><p><strong>Returns</strong></p><ul><li><code>(evaluation, gradient, complete)::Tuple{AbstractVector{T}, AbstractMatrix{T}, Bool}</code>: the normal evaluation,   the gradient, and whether the evaluation completed as normal (or encountered a nan or inf).</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SymbolicML/DynamicExpressions.jl/blob/cd1fc0c66559608b96244285a3bc89e4f4e770ff/src/EvaluateEquationDerivative.jl#L171-L193">source</a></section></article><p>You can compute gradients this with shorthand notation as well (which by default computes gradients with respect to input matrix, rather than constants).</p><pre><code class="nohighlight hljs">    (tree::Node{T})&#39;(X::AbstractMatrix{T}, operators::OperatorEnum; turbo::Bool=false, variable::Bool=true)

Compute the forward-mode derivative of an expression, using a similar
structure and optimization to eval_tree_array. `variable` specifies whether
we should take derivatives with respect to features (i.e., X), or with respect
to every constant in the expression.

# Arguments
- `X::AbstractMatrix{T}`: The data matrix, with each column being a data point.
- `operators::OperatorEnum`: The operators used to create the `tree`. Note that `operators.enable_autodiff`
    must be `true`. This is needed to create the derivative operations.
- `variable::Bool`: Whether to take derivatives with respect to features (i.e., `X` - with `variable=true`),
    or with respect to every constant in the expression (`variable=false`).
- `turbo::Bool`: Use `LoopVectorization.@turbo` for faster evaluation.

# Returns

- `(evaluation, gradient, complete)::Tuple{AbstractVector{T}, AbstractMatrix{T}, Bool}`: the normal evaluation,
    the gradient, and whether the evaluation completed as normal (or encountered a nan or inf).</code></pre><p>Alternatively, you can compute higher-order derivatives by using <code>ForwardDiff</code> on the function <code>differentiable_eval_tree_array</code>, although this will be slower.</p><article class="docstring"><header><a class="docstring-binding" id="DynamicExpressions.EvaluateEquationModule.differentiable_eval_tree_array-Union{Tuple{T}, Tuple{Node{T}, AbstractMatrix{T}, OperatorEnum}} where T&lt;:Number" href="#DynamicExpressions.EvaluateEquationModule.differentiable_eval_tree_array-Union{Tuple{T}, Tuple{Node{T}, AbstractMatrix{T}, OperatorEnum}} where T&lt;:Number"><code>DynamicExpressions.EvaluateEquationModule.differentiable_eval_tree_array</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">differentiable_eval_tree_array(tree::Node, cX::AbstractMatrix, operators::OperatorEnum)</code></pre><p>Evaluate an expression tree in a way that can be auto-differentiated.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SymbolicML/DynamicExpressions.jl/blob/cd1fc0c66559608b96244285a3bc89e4f4e770ff/src/EvaluateEquation.jl#L371-L375">source</a></section></article><h2 id="Printing"><a class="docs-heading-anchor" href="#Printing">Printing</a><a id="Printing-1"></a><a class="docs-heading-anchor-permalink" href="#Printing" title="Permalink"></a></h2><p>You can also print a tree as follows:</p><article class="docstring"><header><a class="docstring-binding" id="DynamicExpressions.EquationModule.string_tree-Tuple{Node, AbstractOperatorEnum}" href="#DynamicExpressions.EquationModule.string_tree-Tuple{Node, AbstractOperatorEnum}"><code>DynamicExpressions.EquationModule.string_tree</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">string_tree(tree::Node, operators::AbstractOperatorEnum[; bracketed, variable_names, f_variable, f_constant])</code></pre><p>Convert an equation to a string.</p><p><strong>Arguments</strong></p><ul><li><code>tree</code>: the tree to convert to a string</li><li><code>operators</code>: the operators used to define the tree</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>bracketed</code>: (optional) whether to put brackets around the outside.</li><li><code>f_variable</code>: (optional) function to convert a variable to a string, of the form <code>(feature::UInt8, variable_names)</code>.</li><li><code>f_constant</code>: (optional) function to convert a constant to a string, of the form <code>(val, bracketed::Bool)</code></li><li><code>variable_names::Union{Array{String, 1}, Nothing}=nothing</code>: (optional) what variables to print for each feature.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SymbolicML/DynamicExpressions.jl/blob/cd1fc0c66559608b96244285a3bc89e4f4e770ff/src/Equation.jl#L250-L264">source</a></section></article><p>When you define an <code>OperatorEnum</code>, the standard <code>show</code> and <code>print</code> methods will be overwritten to use <code>string_tree</code>.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Contents</a><a class="docs-footer-nextpage" href="../types/">Types »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.25 on <span class="colophon-date" title="Saturday 12 August 2023 23:35">Saturday 12 August 2023</span>. Using Julia version 1.9.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
